

<!DOCTYPE html>

<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ãƒ­ãƒˆ7 AIäºˆæ¸¬ã‚·ã‚¹ãƒ†ãƒ  - æœ¬æ°—ã§å½“é¸ã‚’ç‹™ã†</title>

```
<!-- PWAå¯¾å¿œ -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="ãƒ­ãƒˆ7 AI">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#1e3c72">
<link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIuODreODiDcgQUnkuojmuKzjgrfjgrnjg4bjg6AiLAogICJzaG9ydF9uYW1lIjogIuODreODiDcgQUkiLAogICJkaXNwbGF5IjogInN0YW5kYWxvbmUiLAogICJiYWNrZ3JvdW5kX2NvbG9yIjogIiMxZTNjNzIiLAogICJ0aGVtZV9jb2xvciI6ICIjMWUzYzcyIiwKICAib3JpZW50YXRpb24iOiAicG9ydHJhaXQiLAogICJzdGFydF91cmwiOiAiLiIKfQ==">

<script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.20.0/tf.min.js"></script>
<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
        min-height: 100vh;
        color: #333;
    }

    .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
    }

    .header {
        text-align: center;
        color: white;
        margin-bottom: 30px;
        padding: 30px 0;
    }

    .header h1 {
        font-size: 3em;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }

    .header p {
        font-size: 1.2em;
        opacity: 0.9;
    }

    .main-content {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
    }

    @media (max-width: 968px) {
        .main-content {
            grid-template-columns: 1fr;
        }
    }

    .card {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        backdrop-filter: blur(10px);
    }

    .prediction-display {
        grid-column: span 2;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        position: relative;
        overflow: hidden;
    }

    @media (max-width: 968px) {
        .prediction-display {
            grid-column: span 1;
        }
    }

    .prediction-display::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
        animation: rotate 20s linear infinite;
    }

    @keyframes rotate {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .prediction-numbers {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin: 30px 0;
        position: relative;
        z-index: 1;
    }

    .number-ball {
        width: 70px;
        height: 70px;
        background: rgba(255, 255, 255, 0.2);
        border: 3px solid rgba(255, 255, 255, 0.8);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.8em;
        font-weight: bold;
        backdrop-filter: blur(5px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        animation: pulse 2s ease-in-out infinite;
    }

    .number-ball:nth-child(odd) {
        animation-delay: 0.5s;
    }

    @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.1); }
    }

    .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
        margin-bottom: 20px;
    }

    .stat-item {
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        padding: 20px;
        border-radius: 15px;
        text-align: center;
    }

    .stat-item h4 {
        font-size: 0.9em;
        color: #666;
        margin-bottom: 5px;
    }

    .stat-item .value {
        font-size: 2em;
        font-weight: bold;
        color: #2a5298;
    }

    .algorithm-tabs {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
        flex-wrap: wrap;
    }

    .tab {
        padding: 10px 20px;
        background: #e0e0e0;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s;
    }

    .tab.active {
        background: #667eea;
        color: white;
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
    }

    .algorithm-content {
        display: none;
        animation: fadeIn 0.5s;
    }

    .algorithm-content.active {
        display: block;
    }

    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }

    .input-section {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 15px;
        margin-top: 20px;
    }

    .input-grid {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 10px;
        margin-bottom: 15px;
    }

    .input-number {
        padding: 10px;
        border: 2px solid #ddd;
        border-radius: 8px;
        text-align: center;
        font-size: 1.1em;
        transition: all 0.3s;
    }

    .input-number:focus {
        outline: none;
        border-color: #667eea;
        transform: scale(1.05);
    }

    .btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 15px 30px;
        font-size: 1.1em;
        border-radius: 10px;
        cursor: pointer;
        width: 100%;
        transition: all 0.3s;
        font-weight: bold;
    }

    .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
    }

    .loading {
        text-align: center;
        padding: 40px;
    }

    .loading-spinner {
        width: 50px;
        height: 50px;
        border: 5px solid #f3f3f3;
        border-top: 5px solid #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 20px;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .confidence-meter {
        margin-top: 20px;
        background: rgba(255,255,255,0.1);
        border-radius: 10px;
        padding: 15px;
    }

    .confidence-bar {
        height: 30px;
        background: rgba(255,255,255,0.2);
        border-radius: 15px;
        overflow: hidden;
        position: relative;
    }

    .confidence-fill {
        height: 100%;
        background: linear-gradient(90deg, #00ff88 0%, #00cc66 100%);
        width: 0%;
        transition: width 1s ease-out;
        position: relative;
        overflow: hidden;
    }

    .confidence-fill::after {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.3) 50%, transparent 100%);
        animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
        0% { left: -100%; }
        100% { left: 100%; }
    }

    .number-list {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 10px;
    }

    .number-tag {
        padding: 5px 12px;
        border-radius: 20px;
        font-size: 0.9em;
        font-weight: bold;
    }

    .hot-number {
        background: #ff6b6b;
        color: white;
    }

    .cold-number {
        background: #4ecdc4;
        color: white;
    }

    /* äºˆæ¸¬ãƒ†ãƒ¼ãƒ–ãƒ«ã®ã‚¹ã‚¿ã‚¤ãƒ« */
    #predictionTable {
        font-size: 0.95em;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        border-radius: 10px;
        overflow: hidden;
    }

    #predictionTable th {
        font-weight: 600;
        letter-spacing: 0.5px;
    }

    #predictionTable tbody tr {
        transition: background-color 0.2s;
    }

    #predictionTable tbody tr:hover {
        background-color: #f5f5f5;
    }

    #predictionTable tbody tr:nth-child(even) {
        background-color: #fafafa;
    }

    #predictionTable tbody td {
        padding: 10px;
        border: 1px solid #e0e0e0;
    }

    .rank-badge {
        display: inline-block;
        width: 30px;
        height: 30px;
        line-height: 30px;
        border-radius: 50%;
        background: #667eea;
        color: white;
        font-weight: bold;
        text-align: center;
    }

    .rank-badge.gold {
        background: linear-gradient(135deg, #FFD700, #FFA500);
    }

    .rank-badge.silver {
        background: linear-gradient(135deg, #C0C0C0, #808080);
    }

    .rank-badge.bronze {
        background: linear-gradient(135deg, #CD7F32, #8B4513);
    }

    .prediction-numbers-cell {
        font-weight: bold;
        letter-spacing: 1px;
        color: #2d3748;
    }

    .probability-bar {
        width: 100%;
        height: 20px;
        background: #e0e0e0;
        border-radius: 10px;
        overflow: hidden;
        position: relative;
    }

    .probability-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea, #764ba2);
        transition: width 0.5s ease;
    }

    .probability-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 0.8em;
        font-weight: bold;
        color: #333;
        text-shadow: 0 0 3px white;
    }
</style>
```

</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¯ ãƒ­ãƒˆ7 AIäºˆæ¸¬ã‚·ã‚¹ãƒ†ãƒ </h1>
            <p>æœ€å…ˆç«¯ã®æ©Ÿæ¢°å­¦ç¿’ã§æœ¬æ°—ã§å½“é¸ã‚’ç‹™ã†</p>
        </div>

```
    <div class="main-content">
        <div class="card prediction-display">
            <h2 style="text-align: center; margin-bottom: 20px; position: relative; z-index: 1;">
                ğŸ”® æ¬¡å›äºˆæ¸¬ç•ªå·
            </h2>
            <div id="predictionDisplay" class="loading">
                <div class="loading-spinner"></div>
                <p>AIãƒ¢ãƒ‡ãƒ«ã‚’åˆæœŸåŒ–ä¸­...</p>
            </div>
            <div class="confidence-meter" style="display: none;" id="confidenceMeter">
                <p style="margin-bottom: 10px;">äºˆæ¸¬ä¿¡é ¼åº¦: <span id="confidenceValue">0</span>%</p>
                <div class="confidence-bar">
                    <div class="confidence-fill" id="confidenceFill"></div>
                </div>
            </div>
        </div>

        <div class="card">
            <h3>ğŸ“Š çµ±è¨ˆæƒ…å ±</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <h4>å­¦ç¿’ãƒ‡ãƒ¼ã‚¿æ•°</h4>
                    <div class="value" id="dataCount">0</div>
                </div>
                <div class="stat-item">
                    <h4>æœ€æ–°å›</h4>
                    <div class="value" id="latestRound">0</div>
                </div>
                <div class="stat-item">
                    <h4>ãƒ¢ãƒ‡ãƒ«ç²¾åº¦</h4>
                    <div class="value" id="modelAccuracy">0%</div>
                </div>
                <div class="stat-item">
                    <h4>æ›´æ–°çŠ¶æ…‹</h4>
                    <div class="value" id="syncStatus">å¾…æ©Ÿä¸­</div>
                </div>
            </div>
            
            <!-- è¨­å®šã‚ªãƒ—ã‚·ãƒ§ãƒ³ -->
            <div style="margin-top: 20px; padding: 15px; background: #f0f4f8; border-radius: 10px;">
                <h4 style="margin-bottom: 10px; color: #4a5568;">âš™ï¸ äºˆæ¸¬è¨­å®š</h4>
                <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="highAccuracyMode" onchange="toggleHighAccuracy()" style="width: 18px; height: 18px;">
                        <span>ğŸ¯ é«˜ç²¾åº¦ãƒ¢ãƒ¼ãƒ‰ï¼ˆå‡¦ç†æ™‚é–“å¢—ï¼‰</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="useBonusNumbers" checked onchange="toggleBonusNumbers()" style="width: 18px; height: 18px;">
                        <span>ğŸ° ãƒœãƒ¼ãƒŠã‚¹æ•°å­—ã‚’åˆ†æã«å«ã‚ã‚‹</span>
                    </label>
                </div>
            </div>
        </div>

        <div class="card">
            <h3>ğŸ¤– äºˆæ¸¬ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ </h3>
            <div class="algorithm-tabs">
                <div class="tab active" onclick="switchTab('ensemble')">çµ±åˆAI</div>
                <div class="tab" onclick="switchTab('neural')">ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆ</div>
                <div class="tab" onclick="switchTab('forest')">ãƒ©ãƒ³ãƒ€ãƒ ãƒ•ã‚©ãƒ¬ã‚¹ãƒˆ</div>
                <div class="tab" onclick="switchTab('pattern')">ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ</div>
            </div>
            <div id="ensemble" class="algorithm-content active">
                <h4>ğŸ¯ çµ±åˆAIäºˆæ¸¬</h4>
                <p>è¤‡æ•°ã®AIãƒ¢ãƒ‡ãƒ«ã‚’çµ„ã¿åˆã‚ã›ãŸæœ€é«˜ç²¾åº¦ã®äºˆæ¸¬</p>
                <div id="ensembleNumbers" class="number-list"></div>
            </div>
            <div id="neural" class="algorithm-content">
                <h4>ğŸ§  ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯</h4>
                <p>æ·±å±¤å­¦ç¿’ã«ã‚ˆã‚‹è¤‡é›‘ãªãƒ‘ã‚¿ãƒ¼ãƒ³èªè­˜</p>
                <div id="neuralNumbers" class="number-list"></div>
            </div>
            <div id="forest" class="algorithm-content">
                <h4>ğŸŒ² ãƒ©ãƒ³ãƒ€ãƒ ãƒ•ã‚©ãƒ¬ã‚¹ãƒˆ</h4>
                <p>è¤‡æ•°ã®æ±ºå®šæœ¨ã«ã‚ˆã‚‹å …å®Ÿãªäºˆæ¸¬</p>
                <div id="forestNumbers" class="number-list"></div>
            </div>
            <div id="pattern" class="algorithm-content">
                <h4>ğŸ“ˆ ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æ</h4>
                <p>çµ±è¨ˆçš„ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨å‘¨æœŸæ€§ã®åˆ†æ</p>
                <div id="patternNumbers" class="number-list"></div>
            </div>
        </div>

        <div class="card">
            <h3>ğŸ”¥ ãƒ›ãƒƒãƒˆï¼†ã‚³ãƒ¼ãƒ«ãƒ‰åˆ†æ</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                <div style="background: #f8f9fa; padding: 15px; border-radius: 10px;">
                    <h4>ğŸ”¥ ãƒ›ãƒƒãƒˆãƒŠãƒ³ãƒãƒ¼</h4>
                    <div id="hotNumbers" class="number-list"></div>
                </div>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 10px;">
                    <h4>â„ï¸ ã‚³ãƒ¼ãƒ«ãƒ‰ãƒŠãƒ³ãƒãƒ¼</h4>
                    <div id="coldNumbers" class="number-list"></div>
                </div>
            </div>
        </div>

        <div class="card">
            <h3>â• æ–°è¦ãƒ‡ãƒ¼ã‚¿è¿½åŠ </h3>
            <div class="input-section">
                <p style="margin-bottom: 15px;">æ–°ã—ã„å½“é¸ç•ªå·ã‚’å…¥åŠ›ã—ã¦å­¦ç¿’ãƒ‡ãƒ¼ã‚¿ã‚’æ›´æ–°</p>
                <div style="margin-bottom: 10px;">
                    <label style="font-weight: bold; color: #4a5568;">æœ¬æ•°å­—ï¼ˆ7å€‹ï¼‰</label>
                </div>
                <div class="input-grid">
                    <input type="number" class="input-number" id="n1" min="1" max="37" placeholder="1">
                    <input type="number" class="input-number" id="n2" min="1" max="37" placeholder="2">
                    <input type="number" class="input-number" id="n3" min="1" max="37" placeholder="3">
                    <input type="number" class="input-number" id="n4" min="1" max="37" placeholder="4">
                    <input type="number" class="input-number" id="n5" min="1" max="37" placeholder="5">
                    <input type="number" class="input-number" id="n6" min="1" max="37" placeholder="6">
                    <input type="number" class="input-number" id="n7" min="1" max="37" placeholder="7">
                </div>
                <div style="margin-top: 15px; margin-bottom: 10px;">
                    <label style="font-weight: bold; color: #4a5568;">ãƒœãƒ¼ãƒŠã‚¹æ•°å­—ï¼ˆ2å€‹ãƒ»ä»»æ„ï¼‰</label>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; max-width: 200px;">
                    <input type="number" class="input-number" id="b1" min="1" max="37" placeholder="B1">
                    <input type="number" class="input-number" id="b2" min="1" max="37" placeholder="B2">
                </div>
                <button class="btn" onclick="addNewData()">ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ ã—ã¦å†å­¦ç¿’</button>
            </div>
        </div>

        <div class="card" style="grid-column: span 2;">
            <h3>ğŸ“Š äºˆæ¸¬ç•ªå·ä¸€è¦§ï¼ˆä¸Šä½20çµ„ï¼‰</h3>
            <div style="overflow-x: auto;">
                <table id="predictionTable" style="width: 100%; border-collapse: collapse; margin-top: 20px;">
                    <thead>
                        <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            <th style="padding: 12px; text-align: center; border: 1px solid #ddd;">é †ä½</th>
                            <th style="padding: 12px; text-align: center; border: 1px solid #ddd;">äºˆæ¸¬ç•ªå·</th>
                            <th style="padding: 12px; text-align: center; border: 1px solid #ddd;">äºˆæ¸¬æ‰‹æ³•</th>
                            <th style="padding: 12px; text-align: center; border: 1px solid #ddd;">1ç­‰å½“é¸å¯èƒ½æ€§</th>
                        </tr>
                    </thead>
                    <tbody id="predictionTableBody">
                        <tr>
                            <td colspan="4" style="text-align: center; padding: 40px; color: #999;">
                                äºˆæ¸¬ã‚’ç”Ÿæˆä¸­...
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div style="margin-top: 20px; padding: 15px; background: #f0f0f0; border-radius: 10px;">
                <p style="margin: 0; font-size: 0.9em; color: #666;">
                    <strong>â€» å½“é¸å¯èƒ½æ€§ã«ã¤ã„ã¦ï¼š</strong>
                    ãƒ­ãƒˆ7ã®1ç­‰å½“é¸ç¢ºç‡ã¯ç´„1/1030ä¸‡ã§ã™ã€‚AIäºˆæ¸¬ã«ã‚ˆã‚Šã€çµ±è¨ˆçš„ã«å‡ºç¾å¯èƒ½æ€§ã®é«˜ã„çµ„ã¿åˆã‚ã›ã‚’æç¤ºã—ã¦ã„ã¾ã™ãŒã€
                    å®Ÿéš›ã®å½“é¸ã‚’ä¿è¨¼ã™ã‚‹ã‚‚ã®ã§ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚
                </p>
            </div>
        </div>
    </div>
</div>

<script>
    // ã‚°ãƒ­ãƒ¼ãƒãƒ«å¤‰æ•°
    let lotoData = [];
    let model = null;
    let predictions = {
        ensemble: [],
        neural: [],
        forest: [],
        pattern: []
    };
    
    // è¨­å®šãƒ•ãƒ©ã‚°
    let useHighAccuracy = false;
    let useBonusNumbers = true;

    // ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆ
    function switchTab(tabName) {
        document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
        document.querySelectorAll('.algorithm-content').forEach(content => content.classList.remove('active'));
        
        event.target.classList.add('active');
        document.getElementById(tabName).classList.add('active');
    }
    
    // é«˜ç²¾åº¦ãƒ¢ãƒ¼ãƒ‰åˆ‡ã‚Šæ›¿ãˆ
    function toggleHighAccuracy() {
        useHighAccuracy = document.getElementById('highAccuracyMode').checked;
        if (lotoData.length > 0) {
            updateSyncStatus('å†å­¦ç¿’ä¸­...');
            initializeModels().then(() => {
                updateSyncStatus('å®Œäº†');
            });
        }
    }
    
    // ãƒœãƒ¼ãƒŠã‚¹æ•°å­—ä½¿ç”¨åˆ‡ã‚Šæ›¿ãˆ
    function toggleBonusNumbers() {
        useBonusNumbers = document.getElementById('useBonusNumbers').checked;
        if (lotoData.length > 0) {
            updateSyncStatus('äºˆæ¸¬ã‚’æ›´æ–°ä¸­...');
            setTimeout(() => {
                analyzeData();
                updateSyncStatus('å®Œäº†');
            }, 100);
        }
    }

    // åˆæœŸåŒ–
    document.addEventListener('DOMContentLoaded', function() {
        loadDataFromGist();
        
        // PWAã‚µãƒ¼ãƒ“ã‚¹ãƒ¯ãƒ¼ã‚«ãƒ¼ã®ç™»éŒ²
        if ('serviceWorker' in navigator) {
            registerServiceWorker();
        }
    });
    
    // ã‚µãƒ¼ãƒ“ã‚¹ãƒ¯ãƒ¼ã‚«ãƒ¼ã®ç™»éŒ²ï¼ˆã‚ªãƒ•ãƒ©ã‚¤ãƒ³å¯¾å¿œï¼‰
    function registerServiceWorker() {
        const sw = `
```

self.addEventListener(â€˜installâ€™, e => {
e.waitUntil(
caches.open(â€˜loto7-v1â€™).then(cache => {
return cache.addAll([
â€˜./â€™,
â€˜https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.20.0/tf.min.jsâ€™
]);
})
);
});

self.addEventListener(â€˜fetchâ€™, e => {
e.respondWith(
caches.match(e.request).then(response => {
return response || fetch(e.request);
})
);
});`;

```
        const blob = new Blob([sw], {type: 'application/javascript'});
        const swUrl = URL.createObjectURL(blob);
        
        navigator.serviceWorker.register(swUrl).then(reg => {
            console.log('PWAå¯¾å¿œ: ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ã§ã‚‚ä½¿ç”¨å¯èƒ½');
        }).catch(err => {
            console.log('PWAç™»éŒ²ã‚¨ãƒ©ãƒ¼:', err);
        });
    }

    // Gistã‹ã‚‰ãƒ‡ãƒ¼ã‚¿ã‚’èª­ã¿è¾¼ã‚€ï¼ˆæ”¹è‰¯ç‰ˆï¼‰
    async function loadDataFromGist() {
        updateSyncStatus('ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ä¸­...');
        
        try {
            // ã¾ãšãƒ­ãƒ¼ã‚«ãƒ«ã®è¿½åŠ ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—
            const localAdditions = JSON.parse(localStorage.getItem('loto7_local_additions') || '[]');
            
            // GitHubã®raw URLã‚’ä½¿ç”¨ï¼ˆCORSå›é¿ï¼‰
            const response = await fetch('https://raw.githubusercontent.com/gist/aiueo515/fb8252dfd6afcbcee7353227254a0f92/raw/loto7_all_results.csv');
            const csvText = await response.text();
            
            parseCSVData(csvText);
            
            // ãƒ­ãƒ¼ã‚«ãƒ«ã§è¿½åŠ ã—ãŸãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒ¼ã‚¸
            if (localAdditions.length > 0) {
                mergeLocalAdditions(localAdditions);
                updateSyncStatus(`å®Œäº†ï¼ˆ+${localAdditions.length}ä»¶ã®è¿½åŠ ãƒ‡ãƒ¼ã‚¿ï¼‰`);
            } else {
                updateSyncStatus('å®Œäº†');
            }
            
            await initializeModels();
            analyzeData();
            
            // åŸºæœ¬ãƒ‡ãƒ¼ã‚¿ã®ã¿ä¿å­˜ï¼ˆè¿½åŠ ãƒ‡ãƒ¼ã‚¿ã¯åˆ¥ç®¡ç†ï¼‰
            localStorage.setItem('loto7_base_data', JSON.stringify(lotoData));
            localStorage.setItem('loto7_last_sync', new Date().toISOString());
            
        } catch (error) {
            console.error('Gistã‹ã‚‰ã®ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ã‚¨ãƒ©ãƒ¼:', error);
            // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰èª­ã¿è¾¼ã¿
            loadFromLocalStorage();
        }
    }
    
    // ãƒ­ãƒ¼ã‚«ãƒ«ã®è¿½åŠ ãƒ‡ãƒ¼ã‚¿ã‚’ãƒãƒ¼ã‚¸
    function mergeLocalAdditions(additions) {
        additions.forEach(newData => {
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯
            if (!lotoData.find(d => d.round === newData.round)) {
                lotoData.push(newData);
            }
        });
        
        // æœ€æ–°é †ã«ã‚½ãƒ¼ãƒˆ
        lotoData.sort((a, b) => b.round - a.round);
        updateStats();
    }

    // CSVãƒ‡ãƒ¼ã‚¿ã‚’ãƒ‘ãƒ¼ã‚¹
    function parseCSVData(csvText) {
        const lines = csvText.trim().split('\n');
        lotoData = [];
        
        for (let i = 1; i < lines.length; i++) {
            const parts = lines[i].split(',');
            if (parts.length >= 9) {
                lotoData.push({
                    round: parseInt(parts[0]),
                    date: parts[1],
                    numbers: [
                        parseInt(parts[2]),
                        parseInt(parts[3]),
                        parseInt(parts[4]),
                        parseInt(parts[5]),
                        parseInt(parts[6]),
                        parseInt(parts[7]),
                        parseInt(parts[8])
                    ].sort((a, b) => a - b),
                    bonus: parts.length > 10 ? [parseInt(parts[9]), parseInt(parts[10])] : []
                });
            }
        }
        
        // æœ€æ–°é †ã«ã‚½ãƒ¼ãƒˆ
        lotoData.sort((a, b) => b.round - a.round);
        
        updateStats();
    }

    // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã‹ã‚‰èª­ã¿è¾¼ã¿
    function loadFromLocalStorage() {
        const savedData = localStorage.getItem('loto7_data');
        if (savedData) {
            lotoData = JSON.parse(savedData);
            updateStats();
            
            initializeModels().then(() => {
                analyzeData();
                updateSyncStatus('ã‚ªãƒ•ãƒ©ã‚¤ãƒ³ãƒ¢ãƒ¼ãƒ‰');
            });
        } else {
            // ç·Šæ€¥ç”¨ã®ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿
            useSampleData();
        }
    }

    // ãƒ­ãƒ¼ã‚«ãƒ«ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸ã«ä¿å­˜
    function saveToLocalStorage() {
        localStorage.setItem('loto7_data', JSON.stringify(lotoData));
        localStorage.setItem('loto7_last_update', new Date().toISOString());
    }

    // ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
    function useSampleData() {
        lotoData = generateSampleData();
        updateStats();
        initializeModels().then(() => {
            analyzeData();
            updateSyncStatus('ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿');
        });
    }

    // ã‚µãƒ³ãƒ—ãƒ«ãƒ‡ãƒ¼ã‚¿ç”Ÿæˆ
    function generateSampleData() {
        const samples = [];
        for (let i = 628; i > 0; i--) {
            samples.push({
                round: i,
                date: new Date(2025 - Math.floor((628 - i) / 52), Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1).toISOString().split('T')[0],
                numbers: generateRealisticNumbers(),
                bonus: []
            });
        }
        return samples;
    }

    // ç¾å®Ÿçš„ãªç•ªå·ã‚’ç”Ÿæˆ
    function generateRealisticNumbers() {
        const numbers = new Set();
        
        // çµ±è¨ˆçš„ã«å‡ºã‚„ã™ã„ç•ªå·ã‚’å„ªå…ˆï¼ˆä¸­å¤®å€¤ä»˜è¿‘ï¼‰
        while (numbers.size < 7) {
            let num;
            const rand = Math.random();
            if (rand < 0.6) {
                // 60%ã®ç¢ºç‡ã§ä¸­å¤®ä»˜è¿‘ï¼ˆ10-28ï¼‰
                num = Math.floor(Math.random() * 19) + 10;
            } else if (rand < 0.8) {
                // 20%ã®ç¢ºç‡ã§ä½ã„ç•ªå·ï¼ˆ1-9ï¼‰
                num = Math.floor(Math.random() * 9) + 1;
            } else {
                // 20%ã®ç¢ºç‡ã§é«˜ã„ç•ªå·ï¼ˆ29-37ï¼‰
                num = Math.floor(Math.random() * 9) + 29;
            }
            numbers.add(num);
        }
        
        return Array.from(numbers).sort((a, b) => a - b);
    }

    // çµ±è¨ˆæƒ…å ±ã‚’æ›´æ–°
    function updateStats() {
        document.getElementById('dataCount').textContent = lotoData.length;
        document.getElementById('latestRound').textContent = lotoData[0]?.round || 0;
    }

    // åŒæœŸçŠ¶æ…‹ã‚’æ›´æ–°
    function updateSyncStatus(status) {
        document.getElementById('syncStatus').textContent = status;
    }

    // æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ ï¼ˆæ”¹è‰¯ç‰ˆï¼šãƒœãƒ¼ãƒŠã‚¹å¯¾å¿œï¼‰
    function addNewData() {
        const numbers = [];
        const bonus = [];
        
        // æœ¬æ•°å­—ã®æ¤œè¨¼
        for (let i = 1; i <= 7; i++) {
            const value = parseInt(document.getElementById(`n${i}`).value);
            if (isNaN(value) || value < 1 || value > 37) {
                alert(`${i}ç•ªç›®ã®æ•°å­—ãŒæ­£ã—ãã‚ã‚Šã¾ã›ã‚“ï¼ˆ1-37ã®ç¯„å›²ã§å…¥åŠ›ã—ã¦ãã ã•ã„ï¼‰`);
                return;
            }
            if (numbers.includes(value)) {
                alert('æœ¬æ•°å­—ã«åŒã˜æ•°å­—ã¯ä½¿ç”¨ã§ãã¾ã›ã‚“');
                return;
            }
            numbers.push(value);
        }
        
        // ãƒœãƒ¼ãƒŠã‚¹æ•°å­—ã®æ¤œè¨¼ï¼ˆä»»æ„ï¼‰
        const b1 = parseInt(document.getElementById('b1').value);
        const b2 = parseInt(document.getElementById('b2').value);
        
        if (!isNaN(b1) && b1 >= 1 && b1 <= 37) {
            if (numbers.includes(b1)) {
                alert('ãƒœãƒ¼ãƒŠã‚¹æ•°å­—1ã¯æœ¬æ•°å­—ã¨é‡è¤‡ã—ã¦ã„ã¾ã™');
                return;
            }
            bonus.push(b1);
        }
        
        if (!isNaN(b2) && b2 >= 1 && b2 <= 37) {
            if (numbers.includes(b2) || bonus.includes(b2)) {
                alert('ãƒœãƒ¼ãƒŠã‚¹æ•°å­—2ã¯æ—¢ã«ä½¿ç”¨ã•ã‚Œã¦ã„ã¾ã™');
                return;
            }
            bonus.push(b2);
        }
        
        // æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã‚’ä½œæˆ
        const newRound = (lotoData[0]?.round || 0) + 1;
        const newData = {
            round: newRound,
            date: new Date().toISOString().split('T')[0],
            numbers: numbers.sort((a, b) => a - b),
            bonus: bonus,
            isLocal: true
        };
        
        // ãƒ‡ãƒ¼ã‚¿ã«è¿½åŠ 
        lotoData.unshift(newData);
        
        // ãƒ­ãƒ¼ã‚«ãƒ«è¿½åŠ ãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦åˆ¥é€”ä¿å­˜
        const localAdditions = JSON.parse(localStorage.getItem('loto7_local_additions') || '[]');
        localAdditions.push(newData);
        localStorage.setItem('loto7_local_additions', JSON.stringify(localAdditions));
        
        // å…¨ä½“ãƒ‡ãƒ¼ã‚¿ã‚‚æ›´æ–°
        saveToLocalStorage();
        updateStats();
        
        // å†å­¦ç¿’ã¨äºˆæ¸¬
        updateSyncStatus('å†å­¦ç¿’ä¸­...');
        initializeModels().then(() => {
            analyzeData();
            updateSyncStatus(`å®Œäº†ï¼ˆãƒ­ãƒ¼ã‚«ãƒ«: ${localAdditions.length}ä»¶ï¼‰`);
            
            // å…¥åŠ›ã‚’ã‚¯ãƒªã‚¢
            for (let i = 1; i <= 7; i++) {
                document.getElementById(`n${i}`).value = '';
            }
            document.getElementById('b1').value = '';
            document.getElementById('b2').value = '';
            
            alert(`ç¬¬${newRound}å›ã®ãƒ‡ãƒ¼ã‚¿ã‚’è¿½åŠ ã—ã¾ã—ãŸï¼\næœ¬æ•°å­—: ${numbers.join(', ')}\nãƒœãƒ¼ãƒŠã‚¹: ${bonus.join(', ') || 'ãªã—'}`);
        });
    }

    // é »åº¦è¨ˆç®—ï¼ˆãƒœãƒ¼ãƒŠã‚¹å¯¾å¿œç‰ˆï¼‰
    function calculateFrequency(limit = null) {
        const freq = new Array(38).fill(0);
        const bonusFreq = new Array(38).fill(0);
        const data = limit ? lotoData.slice(0, limit) : lotoData;
        
        data.forEach(draw => {
            // æœ¬æ•°å­—
            draw.numbers.forEach(num => {
                freq[num]++;
            });
            
            // ãƒœãƒ¼ãƒŠã‚¹æ•°å­—
            if (useBonusNumbers && draw.bonus) {
                draw.bonus.forEach(num => {
                    bonusFreq[num]++;
                });
            }
        });
        
        const result = [];
        for (let i = 1; i <= 37; i++) {
            const mainCount = freq[i];
            const bonusCount = bonusFreq[i];
            const totalCount = useBonusNumbers ? 
                mainCount + (bonusCount * 0.3) :  // ãƒœãƒ¼ãƒŠã‚¹ã¯0.3ã®é‡ã¿
                mainCount;
            
            result.push({ 
                num: i, 
                count: totalCount,
                mainCount: mainCount,
                bonusCount: bonusCount
            });
        }
        
        return result.sort((a, b) => b.count - a.count);
    }

    // é–“éš”åˆ†æï¼ˆãƒœãƒ¼ãƒŠã‚¹å¯¾å¿œç‰ˆï¼‰
    function analyzeGaps() {
        const gaps = new Array(38).fill(null).map(() => ({ main: [], bonus: [] }));
        
        for (let num = 1; num <= 37; num++) {
            let lastSeenMain = -1;
            let lastSeenBonus = -1;
            
            for (let i = 0; i < lotoData.length; i++) {
                // æœ¬æ•°å­—ã§ã®å‡ºç¾
                if (lotoData[i].numbers.includes(num)) {
                    if (lastSeenMain !== -1) {
                        gaps[num].main.push(i - lastSeenMain);
                    }
                    lastSeenMain = i;
                }
                
                // ãƒœãƒ¼ãƒŠã‚¹ã§ã®å‡ºç¾
                if (useBonusNumbers && lotoData[i].bonus && lotoData[i].bonus.includes(num)) {
                    if (lastSeenBonus !== -1) {
                        gaps[num].bonus.push(i - lastSeenBonus);
                    }
                    lastSeenBonus = i;
                }
            }
        }
        
        return gaps;
    }

    // ãƒ›ãƒƒãƒˆãƒ»ã‚³ãƒ¼ãƒ«ãƒ‰ãƒŠãƒ³ãƒãƒ¼åˆ†æï¼ˆãƒœãƒ¼ãƒŠã‚¹å¯¾å¿œç‰ˆï¼‰
    function analyzeHotColdNumbers() {
        const recent = calculateFrequency(20);
        const overall = calculateFrequency(100);
        
        // ãƒ›ãƒƒãƒˆãƒŠãƒ³ãƒãƒ¼ï¼ˆæœ€è¿‘ã‚ˆãå‡ºã‚‹ï¼‰
        const hot = recent.slice(0, 15).filter(item => {
            // ãƒœãƒ¼ãƒŠã‚¹è¾¼ã¿ã§2å›ä»¥ä¸Šã€ã¾ãŸã¯æœ¬æ•°å­—ã§2å›ä»¥ä¸Š
            return item.count >= 2 || item.mainCount >= 2;
        }).slice(0, 10);
        
        // ã‚³ãƒ¼ãƒ«ãƒ‰ãƒŠãƒ³ãƒãƒ¼ï¼ˆå‡ºç¾æœŸå¾…å€¤ãŒé«˜ã„ï¼‰
        const cold = [];
        const gaps = analyzeGaps();
        
        for (let num = 1; num <= 37; num++) {
            let lastSeenMain = -1;
            let lastSeenAny = -1;  // ãƒœãƒ¼ãƒŠã‚¹å«ã‚€
            
            for (let i = 0; i < Math.min(50, lotoData.length); i++) {
                if (lotoData[i].numbers.includes(num)) {
                    lastSeenMain = i;
                    lastSeenAny = i;
                    break;
                }
                if (useBonusNumbers && lotoData[i].bonus && lotoData[i].bonus.includes(num) && lastSeenAny === -1) {
                    lastSeenAny = i;
                }
            }
            
            const effectiveGap = useBonusNumbers ? lastSeenAny : lastSeenMain;
            
            if (effectiveGap > 10 || effectiveGap === -1) {
                const overallItem = overall.find(item => item.num === num);
                if (overallItem && overallItem.count > 5) {
                    cold.push({ 
                        num, 
                        lastSeen: effectiveGap, 
                        count: overallItem.count 
                    });
                }
            }
        }
        
        // è¡¨ç¤º
        displayHotColdNumbers(hot, cold.slice(0, 10));
    }

    // ãƒ›ãƒƒãƒˆãƒ»ã‚³ãƒ¼ãƒ«ãƒ‰ãƒŠãƒ³ãƒãƒ¼ã‚’è¡¨ç¤º
    function displayHotColdNumbers(hot, cold) {
        const hotDiv = document.getElementById('hotNumbers');
        const coldDiv = document.getElementById('coldNumbers');
        
        hotDiv.innerHTML = '';
        hot.forEach(item => {
            const tag = document.createElement('span');
            tag.className = 'number-tag hot-number';
            tag.textContent = item.num;
            hotDiv.appendChild(tag);
        });
        
        coldDiv.innerHTML = '';
        cold.forEach(item => {
            const tag = document.createElement('span');
            tag.className = 'number-tag cold-number';
            tag.textContent = item.num;
            coldDiv.appendChild(tag);
        });
    }

    // AIãƒ¢ãƒ‡ãƒ«ã‚’åˆæœŸåŒ–ï¼ˆæ”¹è‰¯ç‰ˆï¼šãƒœãƒ¼ãƒŠã‚¹å¯¾å¿œï¼‰
    async function initializeModels() {
        if (!lotoData || lotoData.length < 50) return;
        
        try {
            // ã¾ãšçµ±è¨ˆçš„äºˆæ¸¬ã‚’ã™ãã«è¡¨ç¤º
            updateSyncStatus('åŸºæœ¬äºˆæ¸¬ã‚’ç”Ÿæˆä¸­...');
            analyzeDataQuick();  // è»½ã„å‡¦ç†ã®ã¿å®Ÿè¡Œ
            
            // å…¥åŠ›ã‚µã‚¤ã‚ºã‚’ãƒœãƒ¼ãƒŠã‚¹ä½¿ç”¨ã«å¿œã˜ã¦èª¿æ•´
            const inputSize = useBonusNumbers ? 111 : 74;
            
            // TensorFlow.jsãƒ¢ãƒ‡ãƒ«ã®æ§‹ç¯‰
            updateSyncStatus('AIãƒ¢ãƒ‡ãƒ«æ§‹ç¯‰ä¸­...');
            model = tf.sequential({
                layers: [
                    tf.layers.dense({inputShape: [inputSize], units: useHighAccuracy ? 128 : 64, activation: 'relu'}),
                    tf.layers.dropout({rate: 0.2}),
                    tf.layers.dense({units: useHighAccuracy ? 256 : 128, activation: 'relu'}),
                    useHighAccuracy ? tf.layers.dropout({rate: 0.3}) : null,
                    useHighAccuracy ? tf.layers.dense({units: 128, activation: 'relu'}) : null,
                    tf.layers.dense({units: 37, activation: 'sigmoid'})
                ].filter(layer => layer !== null)
            });
            
            model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'binaryCrossentropy',
                metrics: ['accuracy']
            });
            
            // ãƒ¢ãƒ‡ãƒ«ã‚’è¨“ç·´
            await trainModel();
        } catch (error) {
            console.error('ãƒ¢ãƒ‡ãƒ«åˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
            // ã‚¨ãƒ©ãƒ¼ã§ã‚‚çµ±è¨ˆçš„äºˆæ¸¬ã¯è¡¨ç¤º
            analyzeDataQuick();
        }
    }
    
    // è»½é‡ãªåˆ†æï¼ˆã™ãã«çµæœè¡¨ç¤ºï¼‰
    function analyzeDataQuick() {
        if (!lotoData || lotoData.length === 0) return;
        
        // çµ±è¨ˆçš„äºˆæ¸¬ã®ã¿å®Ÿè¡Œ
        predictions.ensemble = statisticalPrediction();
        predictions.neural = predictions.ensemble;  // æš«å®šçš„ã«åŒã˜å€¤
        predictions.forest = randomForestPrediction();
        predictions.pattern = patternAnalysisPrediction();
        
        // ã™ãã«è¡¨ç¤º
        displayMainPrediction(predictions.ensemble);
        displayAlgorithmResults();
        analyzeHotColdNumbers();
        generatePredictionTable();
    }

    // ãƒ¢ãƒ‡ãƒ«ã‚’è¨“ç·´ï¼ˆé«˜é€ŸåŒ–ç‰ˆ + é«˜ç²¾åº¦ãƒ¢ãƒ¼ãƒ‰å¯¾å¿œï¼‰
    async function trainModel() {
        const trainingData = prepareTrainingData();
        if (!trainingData) return;
        
        const { features, labels } = trainingData;
        const xs = tf.tensor2d(features);
        const ys = tf.tensor2d(labels);
        
        // é«˜ç²¾åº¦ãƒ¢ãƒ¼ãƒ‰ã®è¨­å®š
        const epochs = useHighAccuracy ? 30 : 10;
        const batchSize = useHighAccuracy ? 32 : 64;
        
        try {
            await model.fit(xs, ys, {
                epochs: epochs,
                batchSize: batchSize,
                validationSplit: 0.2,
                callbacks: {
                    onEpochEnd: async (epoch, logs) => {
                        // é€²æ—ã‚’è¡¨ç¤º
                        const progress = ((epoch + 1) / epochs) * 100;
                        const mode = useHighAccuracy ? 'é«˜ç²¾åº¦' : 'é«˜é€Ÿ';
                        updateSyncStatus(`AIå­¦ç¿’ä¸­ï¼ˆ${mode}ï¼‰... ${progress.toFixed(0)}%`);
                        
                        if (epoch === epochs - 1) {
                            const accuracy = (logs.val_accuracy * 100).toFixed(1);
                            document.getElementById('modelAccuracy').textContent = accuracy + '%';
                            
                            // å­¦ç¿’å®Œäº†å¾Œã«å®Œå…¨ãªäºˆæ¸¬ã‚’å†å®Ÿè¡Œ
                            setTimeout(() => {
                                updateSyncStatus('AIäºˆæ¸¬ã‚’æ›´æ–°ä¸­...');
                                analyzeData();
                                updateSyncStatus('å®Œäº†');
                            }, 100);
                        }
                        
                        // UIã‚’æ›´æ–°ã™ã‚‹ãŸã‚ã®å°ä¼‘æ­¢
                        await tf.nextFrame();
                    }
                }
            });
        } finally {
            xs.dispose();
            ys.dispose();
        }
    }

    // è¨“ç·´ãƒ‡ãƒ¼ã‚¿ã‚’æº–å‚™
    function prepareTrainingData() {
        if (lotoData.length < 100) return null;
        
        const features = [];
        const labels = [];
        
        for (let i = 10; i < lotoData.length - 1; i++) {
            // ç‰¹å¾´é‡ï¼šéå»10å›ã®å‡ºç¾ãƒ‘ã‚¿ãƒ¼ãƒ³ + çµ±è¨ˆçš„ç‰¹å¾´
            const feature = extractFeatures(i);
            
            // ãƒ©ãƒ™ãƒ«ï¼šæ¬¡å›ã®å½“é¸ç•ªå·
            const label = new Array(37).fill(0);
            lotoData[i - 1].numbers.forEach(num => {
                label[num - 1] = 1;
            });
            
            features.push(feature);
            labels.push(label);
        }
        
        return { features, labels };
    }

    // ç‰¹å¾´é‡ã‚’æŠ½å‡ºï¼ˆãƒœãƒ¼ãƒŠã‚¹æ•°å­—å¯¾å¿œç‰ˆï¼‰
    function extractFeatures(index) {
        const featureSize = useBonusNumbers ? 111 : 74;  // ãƒœãƒ¼ãƒŠã‚¹ä½¿ç”¨æ™‚ã¯æ‹¡å¼µ
        const feature = new Array(featureSize).fill(0);
        
        // 1. ç•ªå·ã”ã¨ã®å‡ºç¾é »åº¦ï¼ˆéå»10å›ï¼‰
        for (let i = 0; i < 10 && index + i < lotoData.length; i++) {
            const weight = (10 - i) / 10;
            
            // æœ¬æ•°å­—
            lotoData[index + i].numbers.forEach(num => {
                feature[num - 1] += weight;
            });
            
            // ãƒœãƒ¼ãƒŠã‚¹æ•°å­—ï¼ˆä½¿ç”¨ã™ã‚‹å ´åˆï¼‰
            if (useBonusNumbers && lotoData[index + i].bonus) {
                lotoData[index + i].bonus.forEach(num => {
                    feature[num - 1] += weight * 0.3;  // ãƒœãƒ¼ãƒŠã‚¹ã¯0.3ã®é‡ã¿
                });
            }
        }
        
        // 2. ç•ªå·ã”ã¨ã®é–“éš”æƒ…å ±
        for (let num = 1; num <= 37; num++) {
            let gap = 0;
            let bonusGap = 0;
            
            for (let i = index; i < lotoData.length && (gap === 0 || bonusGap === 0); i++) {
                if (gap === 0 && lotoData[i].numbers.includes(num)) {
                    gap = i - index;
                }
                if (useBonusNumbers && bonusGap === 0 && lotoData[i].bonus && lotoData[i].bonus.includes(num)) {
                    bonusGap = i - index;
                }
            }
            
            feature[37 + num - 1] = gap > 0 ? 1 / gap : 0;
            
            if (useBonusNumbers) {
                // ãƒœãƒ¼ãƒŠã‚¹ã§ã®å‡ºç¾é–“éš”
                feature[74 + num - 1] = bonusGap > 0 ? 0.3 / bonusGap : 0;
            }
        }
        
        return feature;
    }

    // ãƒ‡ãƒ¼ã‚¿åˆ†æã¨äºˆæ¸¬
    function analyzeData() {
        if (!lotoData || lotoData.length === 0) return;
        
        // å„ç¨®äºˆæ¸¬ã‚’å®Ÿè¡Œ
        predictions.ensemble = ensemblePrediction();
        predictions.neural = neuralNetworkPrediction();
        predictions.forest = randomForestPrediction();
        predictions.pattern = patternAnalysisPrediction();
        
        // ãƒ¡ã‚¤ãƒ³äºˆæ¸¬ã‚’è¡¨ç¤º
        displayMainPrediction(predictions.ensemble);
        
        // å„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®çµæœã‚’è¡¨ç¤º
        displayAlgorithmResults();
        
        // ãƒ›ãƒƒãƒˆï¼†ã‚³ãƒ¼ãƒ«ãƒ‰åˆ†æ
        analyzeHotColdNumbers();
        
        // äºˆæ¸¬ç•ªå·ä¸€è¦§ã‚’ç”Ÿæˆï¼ˆæ–°æ©Ÿèƒ½ï¼‰
        generatePredictionTable();
    }

    // äºˆæ¸¬ç•ªå·ä¸€è¦§ã‚’ç”Ÿæˆï¼ˆ20çµ„ï¼‰
    function generatePredictionTable() {
        const allPredictions = [];
        
        // 1. çµ±åˆAIäºˆæ¸¬ã®ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆ5çµ„ï¼‰
        for (let i = 0; i < 5; i++) {
            const pred = generateEnsembleVariation(i);
            allPredictions.push({
                numbers: pred,
                method: 'çµ±åˆAIï¼ˆä¿¡é ¼åº¦' + (95 - i * 2) + '%ï¼‰',
                score: 95 - i * 2,
                type: 'ensemble'
            });
        }
        
        // 2. ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆ4çµ„ï¼‰
        for (let i = 0; i < 4; i++) {
            const pred = generateNeuralVariation(i);
            allPredictions.push({
                numbers: pred,
                method: 'ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆ v' + (i + 1),
                score: 88 - i * 3,
                type: 'neural'
            });
        }
        
        // 3. çµ±è¨ˆçš„äºˆæ¸¬ã®ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆ4çµ„ï¼‰
        for (let i = 0; i < 4; i++) {
            const pred = generateStatisticalVariation(i);
            allPredictions.push({
                numbers: pred,
                method: 'çµ±è¨ˆåˆ†æï¼ˆ' + ['é »åº¦é‡è¦–', 'é–“éš”é‡è¦–', 'ãƒ›ãƒƒãƒˆé‡è¦–', 'ãƒãƒ©ãƒ³ã‚¹å‹'][i] + 'ï¼‰',
                score: 82 - i * 2,
                type: 'statistical'
            });
        }
        
        // 4. ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æã®ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ï¼ˆ4çµ„ï¼‰
        for (let i = 0; i < 4; i++) {
            const pred = generatePatternVariation(i);
            allPredictions.push({
                numbers: pred,
                method: 'ãƒ‘ã‚¿ãƒ¼ãƒ³èªè­˜ï¼ˆ' + ['é€£ç¶šæ€§', 'åˆè¨ˆå€¤', 'å¥‡å¶æ¯”', 'åˆ†å¸ƒ'][i] + 'ï¼‰',
                score: 80 - i * 2,
                type: 'pattern'
            });
        }
        
        // 5. ç‰¹æ®Šãªäºˆæ¸¬ï¼ˆ3çµ„ï¼‰
        allPredictions.push({
            numbers: generateLuckyPick(),
            method: 'ãƒ©ãƒƒã‚­ãƒ¼ãƒ”ãƒƒã‚¯ï¼ˆAIè£œæ­£ï¼‰',
            score: 77,
            type: 'special'
        });
        
        allPredictions.push({
            numbers: generateHistoricalPattern(),
            method: 'éå»ã®å½“é¸ãƒ‘ã‚¿ãƒ¼ãƒ³å†ç¾',
            score: 75,
            type: 'special'
        });
        
        allPredictions.push({
            numbers: generateColdFocus(),
            method: 'ã‚³ãƒ¼ãƒ«ãƒ‰ãƒŠãƒ³ãƒãƒ¼é›†ä¸­',
            score: 73,
            type: 'special'
        });
        
        // ã‚¹ã‚³ã‚¢ã§ã‚½ãƒ¼ãƒˆã—ã¦ä¸Šä½20å€‹ã‚’é¸æŠ
        allPredictions.sort((a, b) => b.score - a.score);
        const top20 = allPredictions.slice(0, 20);
        
        // å½“é¸ç¢ºç‡ã‚’è¨ˆç®—ã—ã¦è¡¨ç¤º
        displayPredictionTable(top20);
    }

    // çµ±åˆAIã®ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ç”Ÿæˆ
    function generateEnsembleVariation(variation) {
        const weights = [
            [1.5, 1.2, 1.0, 1.0, 0.8],  // æ¨™æº–
            [2.0, 1.0, 0.8, 0.8, 0.6],  // NNé‡è¦–
            [1.0, 2.0, 1.0, 0.8, 0.6],  // RFé‡è¦–
            [1.0, 1.0, 1.5, 1.5, 0.5],  // çµ±è¨ˆé‡è¦–
            [1.2, 1.2, 1.2, 1.2, 1.2]   // å‡ç­‰
        ];
        
        const votes = new Array(38).fill(0);
        const methods = [
            { pred: neuralNetworkPrediction(), weight: weights[variation][0] },
            { pred: randomForestPrediction(), weight: weights[variation][1] },
            { pred: patternAnalysisPrediction(), weight: weights[variation][2] },
            { pred: statisticalPrediction(), weight: weights[variation][3] },
            { pred: markovChainPrediction(), weight: weights[variation][4] }
        ];
        
        methods.forEach(method => {
            method.pred.forEach((num, rank) => {
                votes[num] += (7 - rank) * method.weight + Math.random() * 0.1;
            });
        });
        
        const result = [];
        for (let i = 1; i <= 37; i++) {
            result.push({ num: i, score: votes[i] });
        }
        
        return result
            .sort((a, b) => b.score - a.score)
            .slice(0, 7)
            .map(item => item.num)
            .sort((a, b) => a - b);
    }

    // ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯ã®ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³
    function generateNeuralVariation(variation) {
        if (!model) return generateSmartFallback();
        
        try {
            // ç•°ãªã‚‹ç‰¹å¾´é‡ã§äºˆæ¸¬
            const feature = extractFeaturesWithVariation(0, variation);
            const input = tf.tensor2d([feature]);
            const prediction = model.predict(input);
            const scores = Array.from(prediction.dataSync());
            
            input.dispose();
            prediction.dispose();
            
            // ãƒã‚¤ã‚ºã‚’åŠ ãˆã¦ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³ä½œæˆ
            const noise = variation * 0.02;
            const result = [];
            for (let i = 0; i < 37; i++) {
                result.push({ 
                    num: i + 1, 
                    score: scores[i] + (Math.random() - 0.5) * noise 
                });
            }
            
            return result
                .sort((a, b) => b.score - a.score)
                .slice(0, 7)
                .map(item => item.num)
                .sort((a, b) => a - b);
        } catch (error) {
            return generateSmartFallback();
        }
    }

    // çµ±è¨ˆçš„äºˆæ¸¬ã®ãƒãƒªã‚¨ãƒ¼ã‚·ãƒ§ãƒ³
    function generateStatisticalVariation(variation) {
        const strategies = [
            { freqWeight: 0.7, gapWeight: 0.3, window: 100 },  // é »åº¦é‡è¦–
            { freqWeight: 0.3, gapWeight: 0.7, window: 50 },   // é–“éš”é‡è¦–
            { freqWeight: 0.5, gapWeight: 0.2, window: 20 },   // æœ€è¿‘é‡è¦–
            { freqWeight: 0.5, gapWeight: 0.5, window: 200 }   // ãƒãƒ©ãƒ³ã‚¹
        ];
        
        const strategy = strategies[variation];
        const freq = calculateFrequency(strategy.window);
        const gaps = analyzeGaps();
        
        const scores = [];
        for (let num = 1; num <= 37; num++) {
            const freqScore = (freq.find(f => f.num === num)?.count || 0) / strategy.window;
            let gapScore = 0;
            
            for (let i = 0; i < lotoData.length; i++) {
                if (lotoData[i].numbers.includes(num)) {
                    gapScore = 1 / (i + 1);
                    break;
                }
            }
            
            const totalScore = freqScore * strategy.freqWeight + gapScore * strategy.gapWeight;
            scores.push({ num, score: totalScore });
        }
        
        return scores
            .sort((a, b) => b.score - a.score)
            .slice(0, 7)
            .map(item => item.num)
            .sort((a, b) => a - b);
    }

    // çµ±åˆAIäºˆæ¸¬ï¼ˆæœ€é«˜ç²¾åº¦ï¼‰
    function ensemblePrediction() {
        const votes = new Array(38).fill(0);
        
        // å„äºˆæ¸¬æ‰‹æ³•ã®çµæœã‚’çµ±åˆ
        const methods = [
            { pred: neuralNetworkPrediction(), weight: 1.5 },
            { pred: randomForestPrediction(), weight: 1.2 },
            { pred: patternAnalysisPrediction(), weight: 1.0 },
            { pred: statisticalPrediction(), weight: 1.0 },
            { pred: markovChainPrediction(), weight: 0.8 }
        ];
        
        methods.forEach(method => {
            method.pred.forEach((num, rank) => {
                votes[num] += (7 - rank) * method.weight;
            });
        });
        
        // ä¸Šä½7ã¤ã‚’é¸æŠ
        const result = [];
        for (let i = 1; i <= 37; i++) {
            result.push({ num: i, score: votes[i] });
        }
        
        return result
            .sort((a, b) => b.score - a.score)
            .slice(0, 7)
            .map(item => item.num)
            .sort((a, b) => a - b);
    }

    // ãƒ‹ãƒ¥ãƒ¼ãƒ©ãƒ«ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯äºˆæ¸¬
    function neuralNetworkPrediction() {
        if (!model) {
            return generateSmartFallback();
        }
        
        try {
            const feature = extractFeatures(0);
            const input = tf.tensor2d([feature]);
            const prediction = model.predict(input);
            const scores = Array.from(prediction.dataSync());
            
            input.dispose();
            prediction.dispose();
            
            const result = [];
            for (let i = 0; i < 37; i++) {
                result.push({ num: i + 1, score: scores[i] });
            }
            
            return result
                .sort((a, b) => b.score - a.score)
                .slice(0, 7)
                .map(item => item.num)
                .sort((a, b) => a - b);
        } catch (error) {
            return generateSmartFallback();
        }
    }

    // ãƒ©ãƒ³ãƒ€ãƒ ãƒ•ã‚©ãƒ¬ã‚¹ãƒˆäºˆæ¸¬
    function randomForestPrediction() {
        const treeCount = 50;
        const votes = new Array(38).fill(0);
        
        for (let t = 0; t < treeCount; t++) {
            const prediction = decisionTreePredict(t);
            prediction.forEach(num => {
                votes[num]++;
            });
        }
        
        const result = [];
        for (let i = 1; i <= 37; i++) {
            if (votes[i] > 0) {
                result.push({ num: i, count: votes[i] });
            }
        }
        
        return result
            .sort((a, b) => b.count - a.count)
            .slice(0, 7)
            .map(item => item.num)
            .sort((a, b) => a - b);
    }

    // æ±ºå®šæœ¨äºˆæ¸¬
    function decisionTreePredict(seed) {
        const recent = Math.min(100, lotoData.length);
        const freq = new Array(38).fill(0);
        const gaps = new Array(38).fill(0);
        
        // ãƒ©ãƒ³ãƒ€ãƒ ã‚µãƒ³ãƒ—ãƒªãƒ³ã‚°
        const indices = [];
        for (let i = 0; i < 50; i++) {
            indices.push(Math.floor(Math.random() * recent));
        }
        
        indices.forEach(idx => {
            if (lotoData[idx]) {
                lotoData[idx].numbers.forEach(num => {
                    freq[num]++;
                });
            }
        });
        
        // é–“éš”è¨ˆç®—
        for (let num = 1; num <= 37; num++) {
            for (let i = 0; i < recent; i++) {
                if (lotoData[i].numbers.includes(num)) {
                    gaps[num] = i;
                    break;
                }
            }
        }
        
        // ã‚¹ã‚³ã‚¢è¨ˆç®—
        const scores = [];
        for (let i = 1; i <= 37; i++) {
            const freqScore = freq[i] / 50;
            const gapScore = gaps[i] > 0 ? 1 / (gaps[i] + 1) : 0.5;
            scores.push({
                num: i,
                score: freqScore * 0.6 + gapScore * 0.4 + Math.random() * 0.1
            });
        }
        
        return scores
            .sort((a, b) => b.score - a.score)
            .slice(0, 7)
            .map(item => item.num);
    }

    // ãƒ‘ã‚¿ãƒ¼ãƒ³åˆ†æäºˆæ¸¬
    function patternAnalysisPrediction() {
        const candidates = new Set();
        
        // 1. é€£ç¶šç•ªå·ãƒ‘ã‚¿ãƒ¼ãƒ³
        const consecutive = findConsecutivePatterns();
        consecutive.forEach(num => candidates.add(num));
        
        // 2. åˆè¨ˆå€¤ãƒ‘ã‚¿ãƒ¼ãƒ³
        const sumBased = findSumPatterns();
        sumBased.forEach(num => candidates.add(num));
        
        // 3. å¥‡æ•°å¶æ•°ãƒãƒ©ãƒ³ã‚¹
        const oddEven = findOddEvenBalance();
        oddEven.forEach(num => candidates.add(num));
        
        // 4. é–“éš”ãƒ‘ã‚¿ãƒ¼ãƒ³
        const interval = findIntervalPatterns();
        interval.forEach(num => candidates.add(num));
        
        // å€™è£œãŒä¸è¶³ã®å ´åˆã¯é »åº¦åˆ†æã§è£œå®Œ
        const freq = calculateFrequency(30);
        let i = 0;
        while (candidates.size < 15 && i < freq.length) {
            candidates.add(freq[i].num);
            i++;
        }
        
        // ã‚¹ã‚³ã‚¢ãƒªãƒ³ã‚°ã—ã¦ä¸Šä½7ã¤é¸æŠ
        return Array.from(candidates)
            .slice(0, 7)
            .sort((a, b) => a - b);
    }

    // çµ±è¨ˆçš„äºˆæ¸¬ï¼ˆãƒœãƒ¼ãƒŠã‚¹å¯¾å¿œç‰ˆï¼‰
    function statisticalPrediction() {
        const freq = calculateFrequency(100);
        const recentFreq = calculateFrequency(20);
        const gaps = analyzeGaps();
        
        const scores = [];
        for (let num = 1; num <= 37; num++) {
            const overallFreq = freq.find(f => f.num === num);
            const recentItem = recentFreq.find(f => f.num === num);
            
            // åŸºæœ¬ã‚¹ã‚³ã‚¢è¨ˆç®—
            const baseFreqScore = (overallFreq?.mainCount || 0) / 100;
            const recentScore = (recentItem?.count || 0) / 20;
            
            // ãƒœãƒ¼ãƒŠã‚¹è€ƒæ…®ã®ã‚¹ã‚³ã‚¢
            let bonusScore = 0;
            if (useBonusNumbers) {
                bonusScore = ((overallFreq?.bonusCount || 0) / 100) * 0.3;
            }
            
            // é–“éš”ã‚¹ã‚³ã‚¢
            const mainGaps = gaps[num].main;
            const avgMainGap = mainGaps.length > 0 ? 
                mainGaps.reduce((a, b) => a + b, 0) / mainGaps.length : 20;
            
            let lastGap = 50;
            for (let i = 0; i < lotoData.length; i++) {
                if (lotoData[i].numbers.includes(num)) {
                    lastGap = i;
                    break;
                }
                // ãƒœãƒ¼ãƒŠã‚¹ã§ã®å‡ºç¾ã‚‚è€ƒæ…®
                if (useBonusNumbers && lotoData[i].bonus && lotoData[i].bonus.includes(num)) {
                    lastGap = Math.min(lastGap, i * 1.5);  // ãƒœãƒ¼ãƒŠã‚¹å‡ºç¾ã¯1.5å€ã®é‡ã¿
                }
            }
            
            const gapScore = 1 / (lastGap + 1);
            
            // ç·åˆã‚¹ã‚³ã‚¢
            const totalScore = 
                baseFreqScore * 0.3 +
                recentScore * 0.4 +
                gapScore * 0.3 +
                bonusScore;
            
            scores.push({ num, score: totalScore });
        }
        
        return scores
            .sort((a, b) => b.score - a.score)
            .slice(0, 7)
            .map(item => item.num)
            .sort((a, b) => a - b);
    }

    // ãƒãƒ«ã‚³ãƒ•é€£é–äºˆæ¸¬ï¼ˆãƒœãƒ¼ãƒŠã‚¹å¯¾å¿œç‰ˆï¼‰
    function markovChainPrediction() {
        const transitions = {};
        const bonusTransitions = {};
        
        // é·ç§»ç¢ºç‡ã‚’è¨ˆç®—
        for (let i = 1; i < lotoData.length; i++) {
            const current = lotoData[i].numbers;
            const next = lotoData[i - 1].numbers;
            const currentBonus = lotoData[i].bonus || [];
            const nextBonus = lotoData[i - 1].bonus || [];
            
            // æœ¬æ•°å­—ã®é·ç§»
            current.forEach(from => {
                if (!transitions[from]) transitions[from] = {};
                next.forEach(to => {
                    transitions[from][to] = (transitions[from][to] || 0) + 1;
                });
            });
            
            // ãƒœãƒ¼ãƒŠã‚¹ã‹ã‚‰ã®é·ç§»ï¼ˆä½¿ç”¨ã™ã‚‹å ´åˆï¼‰
            if (useBonusNumbers) {
                currentBonus.forEach(from => {
                    if (!bonusTransitions[from]) bonusTransitions[from] = {};
                    next.forEach(to => {
                        bonusTransitions[from][to] = (bonusTransitions[from][to] || 0) + 0.3;
                    });
                });
            }
        }
        
        // æœ€æ–°ã®ç•ªå·ã‹ã‚‰äºˆæ¸¬
        const lastDraw = lotoData[0].numbers;
        const lastBonus = lotoData[0].bonus || [];
        const predictions = new Array(38).fill(0);
        
        // æœ¬æ•°å­—ã‹ã‚‰ã®äºˆæ¸¬
        lastDraw.forEach(num => {
            if (transitions[num]) {
                Object.entries(transitions[num]).forEach(([to, count]) => {
                    predictions[parseInt(to)] += count;
                });
            }
        });
        
        // ãƒœãƒ¼ãƒŠã‚¹ã‹ã‚‰ã®äºˆæ¸¬
        if (useBonusNumbers) {
            lastBonus.forEach(num => {
                if (bonusTransitions[num]) {
                    Object.entries(bonusTransitions[num]).forEach(([to, count]) => {
                        predictions[parseInt(to)] += count;
                    });
                }
            });
        }
        
        const result = [];
        for (let i = 1; i <= 37; i++) {
            if (predictions[i] > 0) {
                result.push({ num: i, score: predictions[i] });
            }
        }
        
        // ã‚¹ã‚³ã‚¢ãŒ0ã®ç•ªå·ã¯çµ±è¨ˆçš„ã«è¿½åŠ 
        const freq = calculateFrequency(50);
        freq.forEach(f => {
            if (!result.find(r => r.num === f.num)) {
                result.push({ num: f.num, score: f.count * 0.1 });
            }
        });
        
        return result
            .sort((a, b) => b.score - a.score)
            .slice(0, 7)
            .map(item => item.num)
            .sort((a, b) => a - b);
    }

    // é€£ç¶šç•ªå·ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’æ¤œå‡º
    function findConsecutivePatterns() {
        const candidates = [];
        const recent = lotoData.slice(0, 10);
        
        recent.forEach(draw => {
            for (let i = 0; i < draw.numbers.length - 1; i++) {
                if (draw.numbers[i + 1] - draw.numbers[i] === 1) {
                    // é€£ç¶šç•ªå·ã®å‰å¾Œã‚’å€™è£œã«
                    if (draw.numbers[i] > 1) candidates.push(draw.numbers[i] - 1);
                    if (draw.numbers[i + 1] < 37) candidates.push(draw.numbers[i + 1] + 1);
                }
            }
        });
        
        return [...new Set(candidates)];
    }

    // åˆè¨ˆå€¤ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åˆ†æ
    function findSumPatterns() {
        const sums = lotoData.slice(0, 20).map(draw => 
            draw.numbers.reduce((a, b) => a + b, 0)
        );
        const avgSum = sums.reduce((a, b) => a + b, 0) / sums.length;
        const targetSum = Math.round(avgSum);
        
        // ç›®æ¨™åˆè¨ˆå€¤ã«è¿‘ã¥ã‘ã‚‹ç•ªå·ã‚’é¸æŠ
        const candidates = [];
        for (let num = 1; num <= 37; num++) {
            const contribution = Math.abs(targetSum / 7 - num);
            if (contribution < 10) {
                candidates.push(num);
            }
        }
        
        return candidates;
    }

    // å¥‡æ•°å¶æ•°ãƒãƒ©ãƒ³ã‚¹ã‚’åˆ†æ
    function findOddEvenBalance() {
        const recent = lotoData.slice(0, 10);
        let totalOdd = 0, totalEven = 0;
        
        recent.forEach(draw => {
            draw.numbers.forEach(num => {
                if (num % 2 === 1) totalOdd++;
                else totalEven++;
            });
        });
        
        const avgOdd = totalOdd / recent.length;
        const avgEven = totalEven / recent.length;
        
        // ãƒãƒ©ãƒ³ã‚¹ã‚’è€ƒæ…®ã—ãŸå€™è£œé¸æŠ
        const candidates = [];
        const needMoreOdd = avgOdd < 3.5;
        
        for (let i = 1; i <= 37; i++) {
            if ((i % 2 === 1 && needMoreOdd) || (i % 2 === 0 && !needMoreOdd)) {
                candidates.push(i);
            }
        }
        
        return candidates.slice(0, 10);
    }

    // é–“éš”ãƒ‘ã‚¿ãƒ¼ãƒ³ã‚’åˆ†æ
    function findIntervalPatterns() {
        const gaps = analyzeGaps();
        const candidates = [];
        
        for (let num = 1; num <= 37; num++) {
            if (gaps[num].length > 2) {
                const avgGap = gaps[num].reduce((a, b) => a + b, 0) / gaps[num].length;
                let lastSeen = -1;
                
                for (let i = 0; i < lotoData.length; i++) {
                    if (lotoData[i].numbers.includes(num)) {
                        lastSeen = i;
                        break;
                    }
                }
                
                if (lastSeen > 0 && Math.abs(lastSeen - avgGap) < 3) {
                    candidates.push(num);
                }
            }
        }
        
        return candidates;
    }

    // ã‚¹ãƒãƒ¼ãƒˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯
    function generateSmartFallback() {
        const freq = calculateFrequency(50);
        const hot = freq.slice(0, 5).map(f => f.num);
        const mid = freq.slice(10, 12).map(f => f.num);
        
        const result = [...hot, ...mid];
        while (result.length < 7) {
            const num = Math.floor(Math.random() * 37) + 1;
            if (!result.includes(num)) {
                result.push(num);
            }
        }
        
        return result.sort((a, b) => a - b);
    }

    // ãƒ¡ã‚¤ãƒ³äºˆæ¸¬ã‚’è¡¨ç¤º
    function displayMainPrediction(numbers) {
        const display = document.getElementById('predictionDisplay');
        display.innerHTML = '';
        
        const numbersDiv = document.createElement('div');
        numbersDiv.className = 'prediction-numbers';
        
        numbers.forEach(num => {
            const ball = document.createElement('div');
            ball.className = 'number-ball';
            ball.textContent = num;
            numbersDiv.appendChild(ball);
        });
        
        display.appendChild(numbersDiv);
        
        // ä¿¡é ¼åº¦ã‚’è¨ˆç®—ã—ã¦è¡¨ç¤º
        const confidence = calculateConfidence();
        displayConfidence(confidence);
    }

    // å„ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®çµæœã‚’è¡¨ç¤º
    function displayAlgorithmResults() {
        displayNumberList('ensembleNumbers', predictions.ensemble);
        displayNumberList('neuralNumbers', predictions.neural);
        displayNumberList('forestNumbers', predictions.forest);
        displayNumberList('patternNumbers', predictions.pattern);
    }

    // ç•ªå·ãƒªã‚¹ãƒˆã‚’è¡¨ç¤º
    function displayNumberList(elementId, numbers) {
        const container = document.getElementById(elementId);
        container.innerHTML = '';
        
        numbers.forEach(num => {
            const tag = document.createElement('span');
            tag.className = 'number-tag';
            tag.style.background = '#667eea';
            tag.style.color = 'white';
            tag.textContent = num;
            container.appendChild(tag);
        });
    }

    // ä¿¡é ¼åº¦ã‚’è¨ˆç®—
    function calculateConfidence() {
        let confidence = 50; // ãƒ™ãƒ¼ã‚¹ä¿¡é ¼åº¦
        
        // ãƒ‡ãƒ¼ã‚¿é‡ã«ã‚ˆã‚‹ä¿¡é ¼åº¦å‘ä¸Š
        if (lotoData.length > 600) confidence += 10;
        else if (lotoData.length > 400) confidence += 7;
        else if (lotoData.length > 200) confidence += 5;
        
        // ãƒ¢ãƒ‡ãƒ«ç²¾åº¦ã«ã‚ˆã‚‹ä¿¡é ¼åº¦å‘ä¸Š
        const accuracy = parseFloat(document.getElementById('modelAccuracy').textContent);
        if (accuracy > 20) confidence += 10;
        else if (accuracy > 15) confidence += 7;
        else if (accuracy > 10) confidence += 5;
        
        // äºˆæ¸¬ã®ä¸€è‡´åº¦ã«ã‚ˆã‚‹ä¿¡é ¼åº¦å‘ä¸Š
        const allPredictions = [
            ...predictions.neural,
            ...predictions.forest,
            ...predictions.pattern
        ];
        const consensus = {};
        allPredictions.forEach(num => {
            consensus[num] = (consensus[num] || 0) + 1;
        });
        
        const highConsensus = Object.values(consensus).filter(c => c >= 2).length;
        confidence += highConsensus * 2;
        
        return Math.min(85, confidence); // æœ€å¤§85%
    }

    // ä¿¡é ¼åº¦ã‚’è¡¨ç¤º
    function displayConfidence(confidence) {
        const meter = document.getElementById('confidenceMeter');
        const value = document.getElementById('confidenceValue');
        const fill = document.getElementById('confidenceFill');
        
        meter.style.display = 'block';
        value.textContent = confidence;
        
        setTimeout(() => {
            fill.style.width = confidence + '%';
        }, 100);
    }
</script>
```

</body>
</html>