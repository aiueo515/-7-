

<!DOCTYPE html>

<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>„É≠„Éà7 AI‰∫àÊ∏¨„Ç∑„Çπ„ÉÜ„É† - Êú¨Ê∞ó„ÅßÂΩìÈÅ∏„ÇíÁãô„ÅÜ</title>

```
<!-- PWAÂØæÂøú -->
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="„É≠„Éà7 AI">
<meta name="mobile-web-app-capable" content="yes">
<meta name="theme-color" content="#1e3c72">
<link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIuODreODiDcgQUnkuojmuKzjgrfjgrnjg4bjg6AiLAogICJzaG9ydF9uYW1lIjogIuODreODiDcgQUkiLAogICJkaXNwbGF5IjogInN0YW5kYWxvbmUiLAogICJiYWNrZ3JvdW5kX2NvbG9yIjogIiMxZTNjNzIiLAogICJ0aGVtZV9jb2xvciI6ICIjMWUzYzcyIiwKICAib3JpZW50YXRpb24iOiAicG9ydHJhaXQiLAogICJzdGFydF91cmwiOiAiLiIKfQ==">

<script src="https://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.20.0/tf.min.js"></script>
<style>
    * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
    }

    body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
        min-height: 100vh;
        color: #333;
    }

    .container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
    }

    .header {
        text-align: center;
        color: white;
        margin-bottom: 30px;
        padding: 30px 0;
    }

    .header h1 {
        font-size: 3em;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }

    .header p {
        font-size: 1.2em;
        opacity: 0.9;
    }

    .main-content {
        display: grid;
        grid-template-columns: 1fr 1fr;
        gap: 20px;
    }

    @media (max-width: 968px) {
        .main-content {
            grid-template-columns: 1fr;
        }
    }

    .card {
        background: rgba(255, 255, 255, 0.95);
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 10px 30px rgba(0,0,0,0.2);
        backdrop-filter: blur(10px);
    }

    .prediction-display {
        grid-column: span 2;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        position: relative;
        overflow: hidden;
    }

    @media (max-width: 968px) {
        .prediction-display {
            grid-column: span 1;
        }
    }

    .prediction-display::before {
        content: '';
        position: absolute;
        top: -50%;
        left: -50%;
        width: 200%;
        height: 200%;
        background: radial-gradient(circle, rgba(255,255,255,0.1) 0%, transparent 70%);
        animation: rotate 20s linear infinite;
    }

    @keyframes rotate {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .prediction-numbers {
        display: flex;
        justify-content: center;
        gap: 15px;
        margin: 30px 0;
        position: relative;
        z-index: 1;
    }

    .number-ball {
        width: 70px;
        height: 70px;
        background: rgba(255, 255, 255, 0.2);
        border: 3px solid rgba(255, 255, 255, 0.8);
        border-radius: 50%;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.8em;
        font-weight: bold;
        backdrop-filter: blur(5px);
        box-shadow: 0 5px 15px rgba(0,0,0,0.3);
        animation: pulse 2s ease-in-out infinite;
    }

    .number-ball:nth-child(odd) {
        animation-delay: 0.5s;
    }

    @keyframes pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.1); }
    }

    .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
        gap: 15px;
        margin-bottom: 20px;
    }

    .stat-item {
        background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
        padding: 20px;
        border-radius: 15px;
        text-align: center;
    }

    .stat-item h4 {
        font-size: 0.9em;
        color: #666;
        margin-bottom: 5px;
    }

    .stat-item .value {
        font-size: 2em;
        font-weight: bold;
        color: #2a5298;
    }

    .algorithm-tabs {
        display: flex;
        gap: 10px;
        margin-bottom: 20px;
        flex-wrap: wrap;
    }

    .tab {
        padding: 10px 20px;
        background: #e0e0e0;
        border-radius: 10px;
        cursor: pointer;
        transition: all 0.3s;
    }

    .tab.active {
        background: #667eea;
        color: white;
        transform: translateY(-2px);
        box-shadow: 0 5px 15px rgba(102, 126, 234, 0.3);
    }

    .algorithm-content {
        display: none;
        animation: fadeIn 0.5s;
    }

    .algorithm-content.active {
        display: block;
    }

    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }

    .input-section {
        background: #f8f9fa;
        padding: 20px;
        border-radius: 15px;
        margin-top: 20px;
    }

    .input-grid {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 10px;
        margin-bottom: 15px;
    }

    .input-number {
        padding: 10px;
        border: 2px solid #ddd;
        border-radius: 8px;
        text-align: center;
        font-size: 1.1em;
        transition: all 0.3s;
    }

    .input-number:focus {
        outline: none;
        border-color: #667eea;
        transform: scale(1.05);
    }

    .btn {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 15px 30px;
        font-size: 1.1em;
        border-radius: 10px;
        cursor: pointer;
        width: 100%;
        transition: all 0.3s;
        font-weight: bold;
    }

    .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
    }

    .loading {
        text-align: center;
        padding: 40px;
    }

    .loading-spinner {
        width: 50px;
        height: 50px;
        border: 5px solid #f3f3f3;
        border-top: 5px solid #667eea;
        border-radius: 50%;
        animation: spin 1s linear infinite;
        margin: 0 auto 20px;
    }

    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }

    .confidence-meter {
        margin-top: 20px;
        background: rgba(255,255,255,0.1);
        border-radius: 10px;
        padding: 15px;
    }

    .confidence-bar {
        height: 30px;
        background: rgba(255,255,255,0.2);
        border-radius: 15px;
        overflow: hidden;
        position: relative;
    }

    .confidence-fill {
        height: 100%;
        background: linear-gradient(90deg, #00ff88 0%, #00cc66 100%);
        width: 0%;
        transition: width 1s ease-out;
        position: relative;
        overflow: hidden;
    }

    .confidence-fill::after {
        content: '';
        position: absolute;
        top: 0;
        left: -100%;
        width: 100%;
        height: 100%;
        background: linear-gradient(90deg, transparent 0%, rgba(255,255,255,0.3) 50%, transparent 100%);
        animation: shimmer 2s infinite;
    }

    @keyframes shimmer {
        0% { left: -100%; }
        100% { left: 100%; }
    }

    .number-list {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-top: 10px;
    }

    .number-tag {
        padding: 5px 12px;
        border-radius: 20px;
        font-size: 0.9em;
        font-weight: bold;
    }

    .hot-number {
        background: #ff6b6b;
        color: white;
    }

    .cold-number {
        background: #4ecdc4;
        color: white;
    }

    /* ‰∫àÊ∏¨„ÉÜ„Éº„Éñ„É´„ÅÆ„Çπ„Çø„Ç§„É´ */
    #predictionTable {
        font-size: 0.95em;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        border-radius: 10px;
        overflow: hidden;
    }

    #predictionTable th {
        font-weight: 600;
        letter-spacing: 0.5px;
    }

    #predictionTable tbody tr {
        transition: background-color 0.2s;
    }

    #predictionTable tbody tr:hover {
        background-color: #f5f5f5;
    }

    #predictionTable tbody tr:nth-child(even) {
        background-color: #fafafa;
    }

    #predictionTable tbody td {
        padding: 10px;
        border: 1px solid #e0e0e0;
    }

    .rank-badge {
        display: inline-block;
        width: 30px;
        height: 30px;
        line-height: 30px;
        border-radius: 50%;
        background: #667eea;
        color: white;
        font-weight: bold;
        text-align: center;
    }

    .rank-badge.gold {
        background: linear-gradient(135deg, #FFD700, #FFA500);
    }

    .rank-badge.silver {
        background: linear-gradient(135deg, #C0C0C0, #808080);
    }

    .rank-badge.bronze {
        background: linear-gradient(135deg, #CD7F32, #8B4513);
    }

    .prediction-numbers-cell {
        font-weight: bold;
        letter-spacing: 1px;
        color: #2d3748;
    }

    .probability-bar {
        width: 100%;
        height: 20px;
        background: #e0e0e0;
        border-radius: 10px;
        overflow: hidden;
        position: relative;
    }

    .probability-fill {
        height: 100%;
        background: linear-gradient(90deg, #667eea, #764ba2);
        transition: width 0.5s ease;
    }

    .probability-text {
        position: absolute;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 0.8em;
        font-weight: bold;
        color: #333;
        text-shadow: 0 0 3px white;
    }
</style>
```

</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üéØ „É≠„Éà7 AI‰∫àÊ∏¨„Ç∑„Çπ„ÉÜ„É†</h1>
            <p>ÊúÄÂÖàÁ´Ø„ÅÆÊ©üÊ¢∞Â≠¶Áøí„ÅßÊú¨Ê∞ó„ÅßÂΩìÈÅ∏„ÇíÁãô„ÅÜ</p>
        </div>

```
    <div class="main-content">
        <div class="card prediction-display">
            <h2 style="text-align: center; margin-bottom: 20px; position: relative; z-index: 1;">
                üîÆ Ê¨°Âõû‰∫àÊ∏¨Áï™Âè∑
            </h2>
            <div id="predictionDisplay" class="loading">
                <div class="loading-spinner"></div>
                <p>AI„É¢„Éá„É´„ÇíÂàùÊúüÂåñ‰∏≠...</p>
            </div>
            <div class="confidence-meter" style="display: none;" id="confidenceMeter">
                <p style="margin-bottom: 10px;">‰∫àÊ∏¨‰ø°È†ºÂ∫¶: <span id="confidenceValue">0</span>%</p>
                <div class="confidence-bar">
                    <div class="confidence-fill" id="confidenceFill"></div>
                </div>
            </div>
        </div>

        <div class="card">
            <h3>üìä Áµ±Ë®àÊÉÖÂ†±</h3>
            <div class="stats-grid">
                <div class="stat-item">
                    <h4>Â≠¶Áøí„Éá„Éº„ÇøÊï∞</h4>
                    <div class="value" id="dataCount">0</div>
                </div>
                <div class="stat-item">
                    <h4>ÊúÄÊñ∞Âõû</h4>
                    <div class="value" id="latestRound">0</div>
                </div>
                <div class="stat-item">
                    <h4>„É¢„Éá„É´Á≤æÂ∫¶</h4>
                    <div class="value" id="modelAccuracy">0%</div>
                </div>
                <div class="stat-item">
                    <h4>Êõ¥Êñ∞Áä∂ÊÖã</h4>
                    <div class="value" id="syncStatus">ÂæÖÊ©ü‰∏≠</div>
                </div>
            </div>
            
            <!-- Ë®≠ÂÆö„Ç™„Éó„Ç∑„Éß„É≥ -->
            <div style="margin-top: 20px; padding: 15px; background: #f0f4f8; border-radius: 10px;">
                <h4 style="margin-bottom: 10px; color: #4a5568;">‚öôÔ∏è ‰∫àÊ∏¨Ë®≠ÂÆö</h4>
                <div style="display: flex; gap: 15px; flex-wrap: wrap;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="highAccuracyMode" onchange="toggleHighAccuracy()" style="width: 18px; height: 18px;">
                        <span>üéØ È´òÁ≤æÂ∫¶„É¢„Éº„ÉâÔºàÂá¶ÁêÜÊôÇÈñìÂ¢óÔºâ</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer;">
                        <input type="checkbox" id="useBonusNumbers" checked onchange="toggleBonusNumbers()" style="width: 18px; height: 18px;">
                        <span>üé∞ „Éú„Éº„Éä„ÇπÊï∞Â≠ó„ÇíÂàÜÊûê„Å´Âê´„ÇÅ„Çã</span>
                    </label>
                </div>
            </div>
        </div>

        <div class="card">
            <h3>ü§ñ ‰∫àÊ∏¨„Ç¢„É´„Ç¥„É™„Ç∫„É†</h3>
            <div class="algorithm-tabs">
                <div class="tab active" onclick="switchTab('ensemble')">Áµ±ÂêàAI</div>
                <div class="tab" onclick="switchTab('neural')">„Éã„É•„Éº„É©„É´„Éç„ÉÉ„Éà</div>
                <div class="tab" onclick="switchTab('forest')">„É©„É≥„ÉÄ„É†„Éï„Ç©„É¨„Çπ„Éà</div>
                <div class="tab" onclick="switchTab('pattern')">„Éë„Çø„Éº„É≥ÂàÜÊûê</div>
            </div>
            <div id="ensemble" class="algorithm-content active">
                <h4>üéØ Áµ±ÂêàAI‰∫àÊ∏¨</h4>
                <p>Ë§áÊï∞„ÅÆAI„É¢„Éá„É´„ÇíÁµÑ„ÅøÂêà„Çè„Åõ„ÅüÊúÄÈ´òÁ≤æÂ∫¶„ÅÆ‰∫àÊ∏¨</p>
                <div id="ensembleNumbers" class="number-list"></div>
            </div>
            <div id="neural" class="algorithm-content">
                <h4>üß† „Éã„É•„Éº„É©„É´„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ</h4>
                <p>Ê∑±Â±§Â≠¶Áøí„Å´„Çà„ÇãË§áÈõë„Å™„Éë„Çø„Éº„É≥Ë™çË≠ò</p>
                <div id="neuralNumbers" class="number-list"></div>
            </div>
            <div id="forest" class="algorithm-content">
                <h4>üå≤ „É©„É≥„ÉÄ„É†„Éï„Ç©„É¨„Çπ„Éà</h4>
                <p>Ë§áÊï∞„ÅÆÊ±∫ÂÆöÊú®„Å´„Çà„ÇãÂ†ÖÂÆü„Å™‰∫àÊ∏¨</p>
                <div id="forestNumbers" class="number-list"></div>
            </div>
            <div id="pattern" class="algorithm-content">
                <h4>üìà „Éë„Çø„Éº„É≥ÂàÜÊûê</h4>
                <p>Áµ±Ë®àÁöÑ„Éë„Çø„Éº„É≥„Å®Âë®ÊúüÊÄß„ÅÆÂàÜÊûê</p>
                <div id="patternNumbers" class="number-list"></div>
            </div>
        </div>

        <div class="card">
            <h3>üî• „Éõ„ÉÉ„ÉàÔºÜ„Ç≥„Éº„É´„ÉâÂàÜÊûê</h3>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 20px;">
                <div style="background: #f8f9fa; padding: 15px; border-radius: 10px;">
                    <h4>üî• „Éõ„ÉÉ„Éà„Éä„É≥„Éê„Éº</h4>
                    <div id="hotNumbers" class="number-list"></div>
                </div>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 10px;">
                    <h4>‚ùÑÔ∏è „Ç≥„Éº„É´„Éâ„Éä„É≥„Éê„Éº</h4>
                    <div id="coldNumbers" class="number-list"></div>
                </div>
            </div>
        </div>

        <div class="card">
            <h3>‚ûï Êñ∞Ë¶è„Éá„Éº„ÇøËøΩÂä†</h3>
            <div class="input-section">
                <p style="margin-bottom: 15px;">Êñ∞„Åó„ÅÑÂΩìÈÅ∏Áï™Âè∑„ÇíÂÖ•Âäõ„Åó„Å¶Â≠¶Áøí„Éá„Éº„Çø„ÇíÊõ¥Êñ∞</p>
                <div style="margin-bottom: 10px;">
                    <label style="font-weight: bold; color: #4a5568;">Êú¨Êï∞Â≠óÔºà7ÂÄãÔºâ</label>
                </div>
                <div class="input-grid">
                    <input type="number" class="input-number" id="n1" min="1" max="37" placeholder="1">
                    <input type="number" class="input-number" id="n2" min="1" max="37" placeholder="2">
                    <input type="number" class="input-number" id="n3" min="1" max="37" placeholder="3">
                    <input type="number" class="input-number" id="n4" min="1" max="37" placeholder="4">
                    <input type="number" class="input-number" id="n5" min="1" max="37" placeholder="5">
                    <input type="number" class="input-number" id="n6" min="1" max="37" placeholder="6">
                    <input type="number" class="input-number" id="n7" min="1" max="37" placeholder="7">
                </div>
                <div style="margin-top: 15px; margin-bottom: 10px;">
                    <label style="font-weight: bold; color: #4a5568;">„Éú„Éº„Éä„ÇπÊï∞Â≠óÔºà2ÂÄã„Éª‰ªªÊÑèÔºâ</label>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; max-width: 200px;">
                    <input type="number" class="input-number" id="b1" min="1" max="37" placeholder="B1">
                    <input type="number" class="input-number" id="b2" min="1" max="37" placeholder="B2">
                </div>
                <button class="btn" onclick="addNewData()">„Éá„Éº„Çø„ÇíËøΩÂä†„Åó„Å¶ÂÜçÂ≠¶Áøí</button>
            </div>
        </div>

        <div class="card" style="grid-column: span 2;">
            <h3>üìä ‰∫àÊ∏¨Áï™Âè∑‰∏ÄË¶ßÔºà‰∏ä‰Ωç20ÁµÑÔºâ</h3>
            <div style="overflow-x: auto;">
                <table id="predictionTable" style="width: 100%; border-collapse: collapse; margin-top: 20px;">
                    <thead>
                        <tr style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white;">
                            <th style="padding: 12px; text-align: center; border: 1px solid #ddd;">È†Ü‰Ωç</th>
                            <th style="padding: 12px; text-align: center; border: 1px solid #ddd;">‰∫àÊ∏¨Áï™Âè∑</th>
                            <th style="padding: 12px; text-align: center; border: 1px solid #ddd;">‰∫àÊ∏¨ÊâãÊ≥ï</th>
                            <th style="padding: 12px; text-align: center; border: 1px solid #ddd;">1Á≠âÂΩìÈÅ∏ÂèØËÉΩÊÄß</th>
                        </tr>
                    </thead>
                    <tbody id="predictionTableBody">
                        <tr>
                            <td colspan="4" style="text-align: center; padding: 40px; color: #999;">
                                ‰∫àÊ∏¨„ÇíÁîüÊàê‰∏≠...
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
            <div style="margin-top: 20px; padding: 15px; background: #f0f0f0; border-radius: 10px;">
                <p style="margin: 0; font-size: 0.9em; color: #666;">
                    <strong>‚Äª ÂΩìÈÅ∏ÂèØËÉΩÊÄß„Å´„Å§„ÅÑ„Å¶Ôºö</strong>
                    „É≠„Éà7„ÅÆ1Á≠âÂΩìÈÅ∏Á¢∫Áéá„ÅØÁ¥Ñ1/1030‰∏á„Åß„Åô„ÄÇAI‰∫àÊ∏¨„Å´„Çà„Çä„ÄÅÁµ±Ë®àÁöÑ„Å´Âá∫ÁèæÂèØËÉΩÊÄß„ÅÆÈ´ò„ÅÑÁµÑ„ÅøÂêà„Çè„Åõ„ÇíÊèêÁ§∫„Åó„Å¶„ÅÑ„Åæ„Åô„Åå„ÄÅ
                    ÂÆüÈöõ„ÅÆÂΩìÈÅ∏„Çí‰øùË®º„Åô„Çã„ÇÇ„ÅÆ„Åß„ÅØ„ÅÇ„Çä„Åæ„Åõ„Çì„ÄÇ
                </p>
            </div>
        </div>
    </div>
</div>

<script>
    // „Ç∞„É≠„Éº„Éê„É´Â§âÊï∞
    let lotoData = [];
    let model = null;
    let predictions = {
        ensemble: [],
        neural: [],
        forest: [],
        pattern: []
    };
    
    // Ë®≠ÂÆö„Éï„É©„Ç∞
    let useHighAccuracy = false;
    let useBonusNumbers = true;

    // „Çø„ÉñÂàá„ÇäÊõø„Åà
    function switchTab(tabName) {
        document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
        document.querySelectorAll('.algorithm-content').forEach(content => content.classList.remove('active'));
        
        event.target.classList.add('active');
        document.getElementById(tabName).classList.add('active');
    }
    
    // È´òÁ≤æÂ∫¶„É¢„Éº„ÉâÂàá„ÇäÊõø„Åà
    function toggleHighAccuracy() {
        useHighAccuracy = document.getElementById('highAccuracyMode').checked;
        if (lotoData.length > 0) {
            updateSyncStatus('ÂÜçÂ≠¶Áøí‰∏≠...');
            initializeModels().then(() => {
                updateSyncStatus('ÂÆå‰∫Ü');
            });
        }
    }
    
    // „Éú„Éº„Éä„ÇπÊï∞Â≠ó‰ΩøÁî®Âàá„ÇäÊõø„Åà
    function toggleBonusNumbers() {
        useBonusNumbers = document.getElementById('useBonusNumbers').checked;
        if (lotoData.length > 0) {
            updateSyncStatus('‰∫àÊ∏¨„ÇíÊõ¥Êñ∞‰∏≠...');
            setTimeout(() => {
                analyzeData();
                updateSyncStatus('ÂÆå‰∫Ü');
            }, 100);
        }
    }

    // ÂàùÊúüÂåñ
    document.addEventListener('DOMContentLoaded', function() {
        loadDataFromGist();
        
        // PWA„Çµ„Éº„Éì„Çπ„ÉØ„Éº„Ç´„Éº„ÅÆÁôªÈå≤
        if ('serviceWorker' in navigator) {
            registerServiceWorker();
        }
    });
    
    // „Çµ„Éº„Éì„Çπ„ÉØ„Éº„Ç´„Éº„ÅÆÁôªÈå≤Ôºà„Ç™„Éï„É©„Ç§„É≥ÂØæÂøúÔºâ
    function registerServiceWorker() {
        const sw = `
```

self.addEventListener(‚Äòinstall‚Äô, e => {
e.waitUntil(
caches.open(‚Äòloto7-v1‚Äô).then(cache => {
return cache.addAll([
‚Äò./‚Äô,
‚Äòhttps://cdnjs.cloudflare.com/ajax/libs/tensorflow/4.20.0/tf.min.js‚Äô
]);
})
);
});

self.addEventListener(‚Äòfetch‚Äô, e => {
e.respondWith(
caches.match(e.request).then(response => {
return response || fetch(e.request);
})
);
});`;

```
        const blob = new Blob([sw], {type: 'application/javascript'});
        const swUrl = URL.createObjectURL(blob);
        
        navigator.serviceWorker.register(swUrl).then(reg => {
            console.log('PWAÂØæÂøú: „Ç™„Éï„É©„Ç§„É≥„Åß„ÇÇ‰ΩøÁî®ÂèØËÉΩ');
        }).catch(err => {
            console.log('PWAÁôªÈå≤„Ç®„É©„Éº:', err);
        });
    }

    // Gist„Åã„Çâ„Éá„Éº„Çø„ÇíË™≠„ÅøËæº„ÇÄÔºàÊîπËâØÁâàÔºâ
    async function loadDataFromGist() {
        updateSyncStatus('„Éá„Éº„ÇøË™≠„ÅøËæº„Åø‰∏≠...');
        
        try {
            // „Åæ„Åö„É≠„Éº„Ç´„É´„ÅÆËøΩÂä†„Éá„Éº„Çø„ÇíÂèñÂæó
            const localAdditions = JSON.parse(localStorage.getItem('loto7_local_additions') || '[]');
            
            // GitHub„ÅÆraw URL„Çí‰ΩøÁî®ÔºàCORSÂõûÈÅøÔºâ
            const response = await fetch('https://raw.githubusercontent.com/gist/aiueo515/fb8252dfd6afcbcee7353227254a0f92/raw/loto7_all_results.csv');
            const csvText = await response.text();
            
            parseCSVData(csvText);
            
            // „É≠„Éº„Ç´„É´„ÅßËøΩÂä†„Åó„Åü„Éá„Éº„Çø„Çí„Éû„Éº„Ç∏
            if (localAdditions.length > 0) {
                mergeLocalAdditions(localAdditions);
                updateSyncStatus(`ÂÆå‰∫ÜÔºà+${localAdditions.length}‰ª∂„ÅÆËøΩÂä†„Éá„Éº„ÇøÔºâ`);
            } else {
                updateSyncStatus('ÂÆå‰∫Ü');
            }
            
            await initializeModels();
            analyzeData();
            
            // Âü∫Êú¨„Éá„Éº„Çø„ÅÆ„Åø‰øùÂ≠òÔºàËøΩÂä†„Éá„Éº„Çø„ÅØÂà•ÁÆ°ÁêÜÔºâ
            localStorage.setItem('loto7_base_data', JSON.stringify(lotoData));
            localStorage.setItem('loto7_last_sync', new Date().toISOString());
            
        } catch (error) {
            console.error('Gist„Åã„Çâ„ÅÆ„Éá„Éº„ÇøË™≠„ÅøËæº„Åø„Ç®„É©„Éº:', error);
            // „É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Åã„ÇâË™≠„ÅøËæº„Åø
            loadFromLocalStorage();
        }
    }
    
    // „É≠„Éº„Ç´„É´„ÅÆËøΩÂä†„Éá„Éº„Çø„Çí„Éû„Éº„Ç∏
    function mergeLocalAdditions(additions) {
        additions.forEach(newData => {
            // ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
            if (!lotoData.find(d => d.round === newData.round)) {
                lotoData.push(newData);
            }
        });
        
        // ÊúÄÊñ∞È†Ü„Å´„ÇΩ„Éº„Éà
        lotoData.sort((a, b) => b.round - a.round);
        updateStats();
    }

    // CSV„Éá„Éº„Çø„Çí„Éë„Éº„Çπ
    function parseCSVData(csvText) {
        const lines = csvText.trim().split('\n');
        lotoData = [];
        
        for (let i = 1; i < lines.length; i++) {
            const parts = lines[i].split(',');
            if (parts.length >= 9) {
                lotoData.push({
                    round: parseInt(parts[0]),
                    date: parts[1],
                    numbers: [
                        parseInt(parts[2]),
                        parseInt(parts[3]),
                        parseInt(parts[4]),
                        parseInt(parts[5]),
                        parseInt(parts[6]),
                        parseInt(parts[7]),
                        parseInt(parts[8])
                    ].sort((a, b) => a - b),
                    bonus: parts.length > 10 ? [parseInt(parts[9]), parseInt(parts[10])] : []
                });
            }
        }
        
        // ÊúÄÊñ∞È†Ü„Å´„ÇΩ„Éº„Éà
        lotoData.sort((a, b) => b.round - a.round);
        
        updateStats();
    }

    // „É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Åã„ÇâË™≠„ÅøËæº„Åø
    function loadFromLocalStorage() {
        const savedData = localStorage.getItem('loto7_data');
        if (savedData) {
            lotoData = JSON.parse(savedData);
            updateStats();
            
            initializeModels().then(() => {
                analyzeData();
                updateSyncStatus('„Ç™„Éï„É©„Ç§„É≥„É¢„Éº„Éâ');
            });
        } else {
            // Á∑äÊÄ•Áî®„ÅÆ„Çµ„É≥„Éó„É´„Éá„Éº„Çø
            useSampleData();
        }
    }

    // „É≠„Éº„Ç´„É´„Çπ„Éà„É¨„Éº„Ç∏„Å´‰øùÂ≠ò
    function saveToLocalStorage() {
        localStorage.setItem('loto7_data', JSON.stringify(lotoData));
        localStorage.setItem('loto7_last_update', new Date().toISOString());
    }

    // „Çµ„É≥„Éó„É´„Éá„Éº„Çø„Çí‰ΩøÁî®Ôºà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØÔºâ
    function useSampleData() {
        lotoData = generateSampleData();
        updateStats();
        initializeModels().then(() => {
            analyzeData();
            updateSyncStatus('„Çµ„É≥„Éó„É´„Éá„Éº„Çø');
        });
    }

    // „Çµ„É≥„Éó„É´„Éá„Éº„ÇøÁîüÊàê
    function generateSampleData() {
        const samples = [];
        for (let i = 628; i > 0; i--) {
            samples.push({
                round: i,
                date: new Date(2025 - Math.floor((628 - i) / 52), Math.floor(Math.random() * 12), Math.floor(Math.random() * 28) + 1).toISOString().split('T')[0],
                numbers: generateRealisticNumbers(),
                bonus: []
            });
        }
        return samples;
    }

    // ÁèæÂÆüÁöÑ„Å™Áï™Âè∑„ÇíÁîüÊàê
    function generateRealisticNumbers() {
        const numbers = new Set();
        
        // Áµ±Ë®àÁöÑ„Å´Âá∫„ÇÑ„Åô„ÅÑÁï™Âè∑„ÇíÂÑ™ÂÖàÔºà‰∏≠Â§ÆÂÄ§‰ªòËøëÔºâ
        while (numbers.size < 7) {
            let num;
            const rand = Math.random();
            if (rand < 0.6) {
                // 60%„ÅÆÁ¢∫Áéá„Åß‰∏≠Â§Æ‰ªòËøëÔºà10-28Ôºâ
                num = Math.floor(Math.random() * 19) + 10;
            } else if (rand < 0.8) {
                // 20%„ÅÆÁ¢∫Áéá„Åß‰Ωé„ÅÑÁï™Âè∑Ôºà1-9Ôºâ
                num = Math.floor(Math.random() * 9) + 1;
            } else {
                // 20%„ÅÆÁ¢∫Áéá„ÅßÈ´ò„ÅÑÁï™Âè∑Ôºà29-37Ôºâ
                num = Math.floor(Math.random() * 9) + 29;
            }
            numbers.add(num);
        }
        
        return Array.from(numbers).sort((a, b) => a - b);
    }

    // Áµ±Ë®àÊÉÖÂ†±„ÇíÊõ¥Êñ∞
    function updateStats() {
        document.getElementById('dataCount').textContent = lotoData.length;
        document.getElementById('latestRound').textContent = lotoData[0]?.round || 0;
    }

    // ÂêåÊúüÁä∂ÊÖã„ÇíÊõ¥Êñ∞
    function updateSyncStatus(status) {
        document.getElementById('syncStatus').textContent = status;
    }

    // Êñ∞„Åó„ÅÑ„Éá„Éº„Çø„ÇíËøΩÂä†ÔºàÊîπËâØÁâàÔºö„Éú„Éº„Éä„ÇπÂØæÂøúÔºâ
    function addNewData() {
        const numbers = [];
        const bonus = [];
        
        // Êú¨Êï∞Â≠ó„ÅÆÊ§úË®º
        for (let i = 1; i <= 7; i++) {
            const value = parseInt(document.getElementById(`n${i}`).value);
            if (isNaN(value) || value < 1 || value > 37) {
                alert(`${i}Áï™ÁõÆ„ÅÆÊï∞Â≠ó„ÅåÊ≠£„Åó„Åè„ÅÇ„Çä„Åæ„Åõ„ÇìÔºà1-37„ÅÆÁØÑÂõ≤„ÅßÂÖ•Âäõ„Åó„Å¶„Åè„Å†„Åï„ÅÑÔºâ`);
                return;
            }
            if (numbers.includes(value)) {
                alert('Êú¨Êï∞Â≠ó„Å´Âêå„ÅòÊï∞Â≠ó„ÅØ‰ΩøÁî®„Åß„Åç„Åæ„Åõ„Çì');
                return;
            }
            numbers.push(value);
        }
        
        // „Éú„Éº„Éä„ÇπÊï∞Â≠ó„ÅÆÊ§úË®ºÔºà‰ªªÊÑèÔºâ
        const b1 = parseInt(document.getElementById('b1').value);
        const b2 = parseInt(document.getElementById('b2').value);
        
        if (!isNaN(b1) && b1 >= 1 && b1 <= 37) {
            if (numbers.includes(b1)) {
                alert('„Éú„Éº„Éä„ÇπÊï∞Â≠ó1„ÅØÊú¨Êï∞Â≠ó„Å®ÈáçË§á„Åó„Å¶„ÅÑ„Åæ„Åô');
                return;
            }
            bonus.push(b1);
        }
        
        if (!isNaN(b2) && b2 >= 1 && b2 <= 37) {
            if (numbers.includes(b2) || bonus.includes(b2)) {
                alert('„Éú„Éº„Éä„ÇπÊï∞Â≠ó2„ÅØÊó¢„Å´‰ΩøÁî®„Åï„Çå„Å¶„ÅÑ„Åæ„Åô');
                return;
            }
            bonus.push(b2);
        }
        
        // Êñ∞„Åó„ÅÑ„Éá„Éº„Çø„Çí‰ΩúÊàê
        const newRound = (lotoData[0]?.round || 0) + 1;
        const newData = {
            round: newRound,
            date: new Date().toISOString().split('T')[0],
            numbers: numbers.sort((a, b) => a - b),
            bonus: bonus,
            isLocal: true
        };
        
        // „Éá„Éº„Çø„Å´ËøΩÂä†
        lotoData.unshift(newData);
        
        // „É≠„Éº„Ç´„É´ËøΩÂä†„Éá„Éº„Çø„Å®„Åó„Å¶Âà•ÈÄî‰øùÂ≠ò
        const localAdditions = JSON.parse(localStorage.getItem('loto7_local_additions') || '[]');
        localAdditions.push(newData);
        localStorage.setItem('loto7_local_additions', JSON.stringify(localAdditions));
        
        // ÂÖ®‰Ωì„Éá„Éº„Çø„ÇÇÊõ¥Êñ∞
        saveToLocalStorage();
        updateStats();
        
        // ÂÜçÂ≠¶Áøí„Å®‰∫àÊ∏¨
        updateSyncStatus('ÂÜçÂ≠¶Áøí‰∏≠...');
        initializeModels().then(() => {
            analyzeData();
            updateSyncStatus(`ÂÆå‰∫ÜÔºà„É≠„Éº„Ç´„É´: ${localAdditions.length}‰ª∂Ôºâ`);
            
            // ÂÖ•Âäõ„Çí„ÇØ„É™„Ç¢
            for (let i = 1; i <= 7; i++) {
                document.getElementById(`n${i}`).value = '';
            }
            document.getElementById('b1').value = '';
            document.getElementById('b2').value = '';
            
            alert(`Á¨¨${newRound}Âõû„ÅÆ„Éá„Éº„Çø„ÇíËøΩÂä†„Åó„Åæ„Åó„ÅüÔºÅ\nÊú¨Êï∞Â≠ó: ${numbers.join(', ')}\n„Éú„Éº„Éä„Çπ: ${bonus.join(', ') || '„Å™„Åó'}`);
        });
    }

    // È†ªÂ∫¶Ë®àÁÆóÔºà„Éú„Éº„Éä„ÇπÂØæÂøúÁâàÔºâ
    function calculateFrequency(limit = null) {
        const freq = new Array(38).fill(0);
        const bonusFreq = new Array(38).fill(0);
        const data = limit ? lotoData.slice(0, limit) : lotoData;
        
        data.forEach(draw => {
            // Êú¨Êï∞Â≠ó
            draw.numbers.forEach(num => {
                freq[num]++;
            });
            
            // „Éú„Éº„Éä„ÇπÊï∞Â≠ó
            if (useBonusNumbers && draw.bonus) {
                draw.bonus.forEach(num => {
                    bonusFreq[num]++;
                });
            }
        });
        
        const result = [];
        for (let i = 1; i <= 37; i++) {
            const mainCount = freq[i];
            const bonusCount = bonusFreq[i];
            const totalCount = useBonusNumbers ? 
                mainCount + (bonusCount * 0.3) :  // „Éú„Éº„Éä„Çπ„ÅØ0.3„ÅÆÈáç„Åø
                mainCount;
            
            result.push({ 
                num: i, 
                count: totalCount,
                mainCount: mainCount,
                bonusCount: bonusCount
            });
        }
        
        return result.sort((a, b) => b.count - a.count);
    }

    // ÈñìÈöîÂàÜÊûêÔºà„Éú„Éº„Éä„ÇπÂØæÂøúÁâàÔºâ
    function analyzeGaps() {
        const gaps = new Array(38).fill(null).map(() => ({ main: [], bonus: [] }));
        
        for (let num = 1; num <= 37; num++) {
            let lastSeenMain = -1;
            let lastSeenBonus = -1;
            
            for (let i = 0; i < lotoData.length; i++) {
                // Êú¨Êï∞Â≠ó„Åß„ÅÆÂá∫Áèæ
                if (lotoData[i].numbers.includes(num)) {
                    if (lastSeenMain !== -1) {
                        gaps[num].main.push(i - lastSeenMain);
                    }
                    lastSeenMain = i;
                }
                
                // „Éú„Éº„Éä„Çπ„Åß„ÅÆÂá∫Áèæ
                if (useBonusNumbers && lotoData[i].bonus && lotoData[i].bonus.includes(num)) {
                    if (lastSeenBonus !== -1) {
                        gaps[num].bonus.push(i - lastSeenBonus);
                    }
                    lastSeenBonus = i;
                }
            }
        }
        
        return gaps;
    }

    // „Éõ„ÉÉ„Éà„Éª„Ç≥„Éº„É´„Éâ„Éä„É≥„Éê„ÉºÂàÜÊûêÔºà„Éú„Éº„Éä„ÇπÂØæÂøúÁâàÔºâ
    function analyzeHotColdNumbers() {
        const recent = calculateFrequency(20);
        const overall = calculateFrequency(100);
        
        // „Éõ„ÉÉ„Éà„Éä„É≥„Éê„ÉºÔºàÊúÄËøë„Çà„ÅèÂá∫„ÇãÔºâ
        const hot = recent.slice(0, 15).filter(item => {
            // „Éú„Éº„Éä„ÇπËæº„Åø„Åß2Âõû‰ª•‰∏ä„ÄÅ„Åæ„Åü„ÅØÊú¨Êï∞Â≠ó„Åß2Âõû‰ª•‰∏ä
            return item.count >= 2 || item.mainCount >= 2;
        }).slice(0, 10);
        
        // „Ç≥„Éº„É´„Éâ„Éä„É≥„Éê„ÉºÔºàÂá∫ÁèæÊúüÂæÖÂÄ§„ÅåÈ´ò„ÅÑÔºâ
        const cold = [];
        const gaps = analyzeGaps();
        
        for (let num = 1; num <= 37; num++) {
            let lastSeenMain = -1;
            let lastSeenAny = -1;  // „Éú„Éº„Éä„ÇπÂê´„ÇÄ
            
            for (let i = 0; i < Math.min(50, lotoData.length); i++) {
                if (lotoData[i].numbers.includes(num)) {
                    lastSeenMain = i;
                    lastSeenAny = i;
                    break;
                }
                if (useBonusNumbers && lotoData[i].bonus && lotoData[i].bonus.includes(num) && lastSeenAny === -1) {
                    lastSeenAny = i;
                }
            }
            
            const effectiveGap = useBonusNumbers ? lastSeenAny : lastSeenMain;
            
            if (effectiveGap > 10 || effectiveGap === -1) {
                const overallItem = overall.find(item => item.num === num);
                if (overallItem && overallItem.count > 5) {
                    cold.push({ 
                        num, 
                        lastSeen: effectiveGap, 
                        count: overallItem.count 
                    });
                }
            }
        }
        
        // Ë°®Á§∫
        displayHotColdNumbers(hot, cold.slice(0, 10));
    }

    // „Éõ„ÉÉ„Éà„Éª„Ç≥„Éº„É´„Éâ„Éä„É≥„Éê„Éº„ÇíË°®Á§∫
    function displayHotColdNumbers(hot, cold) {
        const hotDiv = document.getElementById('hotNumbers');
        const coldDiv = document.getElementById('coldNumbers');
        
        hotDiv.innerHTML = '';
        hot.forEach(item => {
            const tag = document.createElement('span');
            tag.className = 'number-tag hot-number';
            tag.textContent = item.num;
            hotDiv.appendChild(tag);
        });
        
        coldDiv.innerHTML = '';
        cold.forEach(item => {
            const tag = document.createElement('span');
            tag.className = 'number-tag cold-number';
            tag.textContent = item.num;
            coldDiv.appendChild(tag);
        });
    }

    // AI„É¢„Éá„É´„ÇíÂàùÊúüÂåñÔºàÊîπËâØÁâàÔºö„Éú„Éº„Éä„ÇπÂØæÂøúÔºâ
    async function initializeModels() {
        if (!lotoData || lotoData.length < 50) return;
        
        try {
            // „Åæ„ÅöÁµ±Ë®àÁöÑ‰∫àÊ∏¨„Çí„Åô„Åê„Å´Ë°®Á§∫
            updateSyncStatus('Âü∫Êú¨‰∫àÊ∏¨„ÇíÁîüÊàê‰∏≠...');
            analyzeDataQuick();  // ËªΩ„ÅÑÂá¶ÁêÜ„ÅÆ„ÅøÂÆüË°å
            
            // ÂÖ•Âäõ„Çµ„Ç§„Ç∫„Çí„Éú„Éº„Éä„Çπ‰ΩøÁî®„Å´Âøú„Åò„Å¶Ë™øÊï¥
            const inputSize = useBonusNumbers ? 111 : 74;
            
            // TensorFlow.js„É¢„Éá„É´„ÅÆÊßãÁØâ
            updateSyncStatus('AI„É¢„Éá„É´ÊßãÁØâ‰∏≠...');
            model = tf.sequential({
                layers: [
                    tf.layers.dense({inputShape: [inputSize], units: useHighAccuracy ? 128 : 64, activation: 'relu'}),
                    tf.layers.dropout({rate: 0.2}),
                    tf.layers.dense({units: useHighAccuracy ? 256 : 128, activation: 'relu'}),
                    useHighAccuracy ? tf.layers.dropout({rate: 0.3}) : null,
                    useHighAccuracy ? tf.layers.dense({units: 128, activation: 'relu'}) : null,
                    tf.layers.dense({units: 37, activation: 'sigmoid'})
                ].filter(layer => layer !== null)
            });
            
            model.compile({
                optimizer: tf.train.adam(0.001),
                loss: 'binaryCrossentropy',
                metrics: ['accuracy']
            });
            
            // „É¢„Éá„É´„ÇíË®ìÁ∑¥
            await trainModel();
        } catch (error) {
            console.error('„É¢„Éá„É´ÂàùÊúüÂåñ„Ç®„É©„Éº:', error);
            // „Ç®„É©„Éº„Åß„ÇÇÁµ±Ë®àÁöÑ‰∫àÊ∏¨„ÅØË°®Á§∫
            analyzeDataQuick();
        }
    }
    
    // ËªΩÈáè„Å™ÂàÜÊûêÔºà„Åô„Åê„Å´ÁµêÊûúË°®Á§∫Ôºâ
    function analyzeDataQuick() {
        if (!lotoData || lotoData.length === 0) return;
        
        // Áµ±Ë®àÁöÑ‰∫àÊ∏¨„ÅÆ„ÅøÂÆüË°å
        predictions.ensemble = statisticalPrediction();
        predictions.neural = predictions.ensemble;  // Êö´ÂÆöÁöÑ„Å´Âêå„ÅòÂÄ§
        predictions.forest = randomForestPrediction();
        predictions.pattern = patternAnalysisPrediction();
        
        // „Åô„Åê„Å´Ë°®Á§∫
        displayMainPrediction(predictions.ensemble);
        displayAlgorithmResults();
        analyzeHotColdNumbers();
        generatePredictionTable();
    }

    // „É¢„Éá„É´„ÇíË®ìÁ∑¥ÔºàÈ´òÈÄüÂåñÁâà + È´òÁ≤æÂ∫¶„É¢„Éº„ÉâÂØæÂøúÔºâ
    async function trainModel() {
        const trainingData = prepareTrainingData();
        if (!trainingData) return;
        
        const { features, labels } = trainingData;
        const xs = tf.tensor2d(features);
        const ys = tf.tensor2d(labels);
        
        // È´òÁ≤æÂ∫¶„É¢„Éº„Éâ„ÅÆË®≠ÂÆö
        const epochs = useHighAccuracy ? 30 : 10;
        const batchSize = useHighAccuracy ? 32 : 64;
        
        try {
            await model.fit(xs, ys, {
                epochs: epochs,
                batchSize: batchSize,
                validationSplit: 0.2,
                callbacks: {
                    onEpochEnd: async (epoch, logs) => {
                        // ÈÄ≤Êçó„ÇíË°®Á§∫
                        const progress = ((epoch + 1) / epochs) * 100;
                        const mode = useHighAccuracy ? 'È´òÁ≤æÂ∫¶' : 'È´òÈÄü';
                        updateSyncStatus(`AIÂ≠¶Áøí‰∏≠Ôºà${mode}Ôºâ... ${progress.toFixed(0)}%`);
                        
                        if (epoch === epochs - 1) {
                            const accuracy = (logs.val_accuracy * 100).toFixed(1);
                            document.getElementById('modelAccuracy').textContent = accuracy + '%';
                            
                            // Â≠¶ÁøíÂÆå‰∫ÜÂæå„Å´ÂÆåÂÖ®„Å™‰∫àÊ∏¨„ÇíÂÜçÂÆüË°å
                            setTimeout(() => {
                                updateSyncStatus('AI‰∫àÊ∏¨„ÇíÊõ¥Êñ∞‰∏≠...');
                                analyzeData();
                                updateSyncStatus('ÂÆå‰∫Ü');
                            }, 100);
                        }
                        
                        // UI„ÇíÊõ¥Êñ∞„Åô„Çã„Åü„ÇÅ„ÅÆÂ∞è‰ºëÊ≠¢
                        await tf.nextFrame();
                    }
                }
            });
        } finally {
            xs.dispose();
            ys.dispose();
        }
    }

    // Ë®ìÁ∑¥„Éá„Éº„Çø„ÇíÊ∫ñÂÇô
    function prepareTrainingData() {
        if (lotoData.length < 100) return null;
        
        const features = [];
        const labels = [];
        
        for (let i = 10; i < lotoData.length - 1; i++) {
            // ÁâπÂæ¥ÈáèÔºöÈÅéÂéª10Âõû„ÅÆÂá∫Áèæ„Éë„Çø„Éº„É≥ + Áµ±Ë®àÁöÑÁâπÂæ¥
            const feature = extractFeatures(i);
            
            // „É©„Éô„É´ÔºöÊ¨°Âõû„ÅÆÂΩìÈÅ∏Áï™Âè∑
            const label = new Array(37).fill(0);
            lotoData[i - 1].numbers.forEach(num => {
                label[num - 1] = 1;
            });
            
            features.push(feature);
            labels.push(label);
        }
        
        return { features, labels };
    }

    // ÁâπÂæ¥Èáè„ÇíÊäΩÂá∫Ôºà„Éú„Éº„Éä„ÇπÊï∞Â≠óÂØæÂøúÁâàÔºâ
    function extractFeatures(index) {
        const featureSize = useBonusNumbers ? 111 : 74;  // „Éú„Éº„Éä„Çπ‰ΩøÁî®ÊôÇ„ÅØÊã°Âºµ
        const feature = new Array(featureSize).fill(0);
        
        // 1. Áï™Âè∑„Åî„Å®„ÅÆÂá∫ÁèæÈ†ªÂ∫¶ÔºàÈÅéÂéª10ÂõûÔºâ
        for (let i = 0; i < 10 && index + i < lotoData.length; i++) {
            const weight = (10 - i) / 10;
            
            // Êú¨Êï∞Â≠ó
            lotoData[index + i].numbers.forEach(num => {
                feature[num - 1] += weight;
            });
            
            // „Éú„Éº„Éä„ÇπÊï∞Â≠óÔºà‰ΩøÁî®„Åô„ÇãÂ†¥ÂêàÔºâ
            if (useBonusNumbers && lotoData[index + i].bonus) {
                lotoData[index + i].bonus.forEach(num => {
                    feature[num - 1] += weight * 0.3;  // „Éú„Éº„Éä„Çπ„ÅØ0.3„ÅÆÈáç„Åø
                });
            }
        }
        
        // 2. Áï™Âè∑„Åî„Å®„ÅÆÈñìÈöîÊÉÖÂ†±
        for (let num = 1; num <= 37; num++) {
            let gap = 0;
            let bonusGap = 0;
            
            for (let i = index; i < lotoData.length && (gap === 0 || bonusGap === 0); i++) {
                if (gap === 0 && lotoData[i].numbers.includes(num)) {
                    gap = i - index;
                }
                if (useBonusNumbers && bonusGap === 0 && lotoData[i].bonus && lotoData[i].bonus.includes(num)) {
                    bonusGap = i - index;
                }
            }
            
            feature[37 + num - 1] = gap > 0 ? 1 / gap : 0;
            
            if (useBonusNumbers) {
                // „Éú„Éº„Éä„Çπ„Åß„ÅÆÂá∫ÁèæÈñìÈöî
                feature[74 + num - 1] = bonusGap > 0 ? 0.3 / bonusGap : 0;
            }
        }
        
        return feature;
    }

    // „Éá„Éº„ÇøÂàÜÊûê„Å®‰∫àÊ∏¨
    function analyzeData() {
        if (!lotoData || lotoData.length === 0) return;
        
        // ÂêÑÁ®Æ‰∫àÊ∏¨„ÇíÂÆüË°å
        predictions.ensemble = ensemblePrediction();
        predictions.neural = neuralNetworkPrediction();
        predictions.forest = randomForestPrediction();
        predictions.pattern = patternAnalysisPrediction();
        
        // „É°„Ç§„É≥‰∫àÊ∏¨„ÇíË°®Á§∫
        displayMainPrediction(predictions.ensemble);
        
        // ÂêÑ„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÅÆÁµêÊûú„ÇíË°®Á§∫
        displayAlgorithmResults();
        
        // „Éõ„ÉÉ„ÉàÔºÜ„Ç≥„Éº„É´„ÉâÂàÜÊûê
        analyzeHotColdNumbers();
        
        // ‰∫àÊ∏¨Áï™Âè∑‰∏ÄË¶ß„ÇíÁîüÊàêÔºàÊñ∞Ê©üËÉΩÔºâ
        generatePredictionTable();
    }

    // ‰∫àÊ∏¨Áï™Âè∑‰∏ÄË¶ß„ÇíÁîüÊàêÔºà20ÁµÑÔºâ
    function generatePredictionTable() {
        const allPredictions = [];
        
        // 1. Áµ±ÂêàAI‰∫àÊ∏¨„ÅÆ„Éê„É™„Ç®„Éº„Ç∑„Éß„É≥Ôºà5ÁµÑÔºâ
        for (let i = 0; i < 5; i++) {
            const pred = generateEnsembleVariation(i);
            allPredictions.push({
                numbers: pred,
                method: 'Áµ±ÂêàAIÔºà‰ø°È†ºÂ∫¶' + (95 - i * 2) + '%Ôºâ',
                score: 95 - i * 2,
                type: 'ensemble'
            });
        }
        
        // 2. „Éã„É•„Éº„É©„É´„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„ÅÆ„Éê„É™„Ç®„Éº„Ç∑„Éß„É≥Ôºà4ÁµÑÔºâ
        for (let i = 0; i < 4; i++) {
            const pred = generateNeuralVariation(i);
            allPredictions.push({
                numbers: pred,
                method: '„Éã„É•„Éº„É©„É´„Éç„ÉÉ„Éà v' + (i + 1),
                score: 88 - i * 3,
                type: 'neural'
            });
        }
        
        // 3. Áµ±Ë®àÁöÑ‰∫àÊ∏¨„ÅÆ„Éê„É™„Ç®„Éº„Ç∑„Éß„É≥Ôºà4ÁµÑÔºâ
        for (let i = 0; i < 4; i++) {
            const pred = generateStatisticalVariation(i);
            allPredictions.push({
                numbers: pred,
                method: 'Áµ±Ë®àÂàÜÊûêÔºà' + ['È†ªÂ∫¶ÈáçË¶ñ', 'ÈñìÈöîÈáçË¶ñ', '„Éõ„ÉÉ„ÉàÈáçË¶ñ', '„Éê„É©„É≥„ÇπÂûã'][i] + 'Ôºâ',
                score: 82 - i * 2,
                type: 'statistical'
            });
        }
        
        // 4. „Éë„Çø„Éº„É≥ÂàÜÊûê„ÅÆ„Éê„É™„Ç®„Éº„Ç∑„Éß„É≥Ôºà4ÁµÑÔºâ
        for (let i = 0; i < 4; i++) {
            const pred = generatePatternVariation(i);
            allPredictions.push({
                numbers: pred,
                method: '„Éë„Çø„Éº„É≥Ë™çË≠òÔºà' + ['ÈÄ£Á∂öÊÄß', 'ÂêàË®àÂÄ§', 'Â•áÂÅ∂ÊØî', 'ÂàÜÂ∏É'][i] + 'Ôºâ',
                score: 80 - i * 2,
                type: 'pattern'
            });
        }
        
        // 5. ÁâπÊÆä„Å™‰∫àÊ∏¨Ôºà3ÁµÑÔºâ
        allPredictions.push({
            numbers: generateLuckyPick(),
            method: '„É©„ÉÉ„Ç≠„Éº„Éî„ÉÉ„ÇØÔºàAIË£úÊ≠£Ôºâ',
            score: 77,
            type: 'special'
        });
        
        allPredictions.push({
            numbers: generateHistoricalPattern(),
            method: 'ÈÅéÂéª„ÅÆÂΩìÈÅ∏„Éë„Çø„Éº„É≥ÂÜçÁèæ',
            score: 75,
            type: 'special'
        });
        
        allPredictions.push({
            numbers: generateColdFocus(),
            method: '„Ç≥„Éº„É´„Éâ„Éä„É≥„Éê„ÉºÈõÜ‰∏≠',
            score: 73,
            type: 'special'
        });
        
        // „Çπ„Ç≥„Ç¢„Åß„ÇΩ„Éº„Éà„Åó„Å¶‰∏ä‰Ωç20ÂÄã„ÇíÈÅ∏Êäû
        allPredictions.sort((a, b) => b.score - a.score);
        const top20 = allPredictions.slice(0, 20);
        
        // ÂΩìÈÅ∏Á¢∫Áéá„ÇíË®àÁÆó„Åó„Å¶Ë°®Á§∫
        displayPredictionTable(top20);
    }

    // Áµ±ÂêàAI„ÅÆ„Éê„É™„Ç®„Éº„Ç∑„Éß„É≥ÁîüÊàê
    function generateEnsembleVariation(variation) {
        const weights = [
            [1.5, 1.2, 1.0, 1.0, 0.8],  // Ê®ôÊ∫ñ
            [2.0, 1.0, 0.8, 0.8, 0.6],  // NNÈáçË¶ñ
            [1.0, 2.0, 1.0, 0.8, 0.6],  // RFÈáçË¶ñ
            [1.0, 1.0, 1.5, 1.5, 0.5],  // Áµ±Ë®àÈáçË¶ñ
            [1.2, 1.2, 1.2, 1.2, 1.2]   // ÂùáÁ≠â
        ];
        
        const votes = new Array(38).fill(0);
        const methods = [
            { pred: neuralNetworkPrediction(), weight: weights[variation][0] },
            { pred: randomForestPrediction(), weight: weights[variation][1] },
            { pred: patternAnalysisPrediction(), weight: weights[variation][2] },
            { pred: statisticalPrediction(), weight: weights[variation][3] },
            { pred: markovChainPrediction(), weight: weights[variation][4] }
        ];
        
        methods.forEach(method => {
            method.pred.forEach((num, rank) => {
                votes[num] += (7 - rank) * method.weight + Math.random() * 0.1;
            });
        });
        
        const result = [];
        for (let i = 1; i <= 37; i++) {
            result.push({ num: i, score: votes[i] });
        }
        
        return result
            .sort((a, b) => b.score - a.score)
            .slice(0, 7)
            .map(item => item.num)
            .sort((a, b) => a - b);
    }

    // „Éã„É•„Éº„É©„É´„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ„ÅÆ„Éê„É™„Ç®„Éº„Ç∑„Éß„É≥
    function generateNeuralVariation(variation) {
        if (!model) return generateSmartFallback();
        
        try {
            // Áï∞„Å™„ÇãÁâπÂæ¥Èáè„Åß‰∫àÊ∏¨
            const feature = extractFeaturesWithVariation(0, variation);
            const input = tf.tensor2d([feature]);
            const prediction = model.predict(input);
            const scores = Array.from(prediction.dataSync());
            
            input.dispose();
            prediction.dispose();
            
            // „Éé„Ç§„Ç∫„ÇíÂä†„Åà„Å¶„Éê„É™„Ç®„Éº„Ç∑„Éß„É≥‰ΩúÊàê
            const noise = variation * 0.02;
            const result = [];
            for (let i = 0; i < 37; i++) {
                result.push({ 
                    num: i + 1, 
                    score: scores[i] + (Math.random() - 0.5) * noise 
                });
            }
            
            return result
                .sort((a, b) => b.score - a.score)
                .slice(0, 7)
                .map(item => item.num)
                .sort((a, b) => a - b);
        } catch (error) {
            return generateSmartFallback();
        }
    }

    // Áµ±Ë®àÁöÑ‰∫àÊ∏¨„ÅÆ„Éê„É™„Ç®„Éº„Ç∑„Éß„É≥
    function generateStatisticalVariation(variation) {
        const strategies = [
            { freqWeight: 0.7, gapWeight: 0.3, window: 100 },  // È†ªÂ∫¶ÈáçË¶ñ
            { freqWeight: 0.3, gapWeight: 0.7, window: 50 },   // ÈñìÈöîÈáçË¶ñ
            { freqWeight: 0.5, gapWeight: 0.2, window: 20 },   // ÊúÄËøëÈáçË¶ñ
            { freqWeight: 0.5, gapWeight: 0.5, window: 200 }   // „Éê„É©„É≥„Çπ
        ];
        
        const strategy = strategies[variation];
        const freq = calculateFrequency(strategy.window);
        const gaps = analyzeGaps();
        
        const scores = [];
        for (let num = 1; num <= 37; num++) {
            const freqScore = (freq.find(f => f.num === num)?.count || 0) / strategy.window;
            let gapScore = 0;
            
            for (let i = 0; i < lotoData.length; i++) {
                if (lotoData[i].numbers.includes(num)) {
                    gapScore = 1 / (i + 1);
                    break;
                }
            }
            
            const totalScore = freqScore * strategy.freqWeight + gapScore * strategy.gapWeight;
            scores.push({ num, score: totalScore });
        }
        
        return scores
            .sort((a, b) => b.score - a.score)
            .slice(0, 7)
            .map(item => item.num)
            .sort((a, b) => a - b);
    }

    // Áµ±ÂêàAI‰∫àÊ∏¨ÔºàÊúÄÈ´òÁ≤æÂ∫¶Ôºâ
    function ensemblePrediction() {
        const votes = new Array(38).fill(0);
        
        // ÂêÑ‰∫àÊ∏¨ÊâãÊ≥ï„ÅÆÁµêÊûú„ÇíÁµ±Âêà
        const methods = [
            { pred: neuralNetworkPrediction(), weight: 1.5 },
            { pred: randomForestPrediction(), weight: 1.2 },
            { pred: patternAnalysisPrediction(), weight: 1.0 },
            { pred: statisticalPrediction(), weight: 1.0 },
            { pred: markovChainPrediction(), weight: 0.8 }
        ];
        
        methods.forEach(method => {
            method.pred.forEach((num, rank) => {
                votes[num] += (7 - rank) * method.weight;
            });
        });
        
        // ‰∏ä‰Ωç7„Å§„ÇíÈÅ∏Êäû
        const result = [];
        for (let i = 1; i <= 37; i++) {
            result.push({ num: i, score: votes[i] });
        }
        
        return result
            .sort((a, b) => b.score - a.score)
            .slice(0, 7)
            .map(item => item.num)
            .sort((a, b) => a - b);
    }

    // „Éã„É•„Éº„É©„É´„Éç„ÉÉ„Éà„ÉØ„Éº„ÇØ‰∫àÊ∏¨
    function neuralNetworkPrediction() {
        if (!model) {
            return generateSmartFallback();
        }
        
        try {
            const feature = extractFeatures(0);
            const input = tf.tensor2d([feature]);
            const prediction = model.predict(input);
            const scores = Array.from(prediction.dataSync());
            
            input.dispose();
            prediction.dispose();
            
            const result = [];
            for (let i = 0; i < 37; i++) {
                result.push({ num: i + 1, score: scores[i] });
            }
            
            return result
                .sort((a, b) => b.score - a.score)
                .slice(0, 7)
                .map(item => item.num)
                .sort((a, b) => a - b);
        } catch (error) {
            return generateSmartFallback();
        }
    }

    // „É©„É≥„ÉÄ„É†„Éï„Ç©„É¨„Çπ„Éà‰∫àÊ∏¨
    function randomForestPrediction() {
        const treeCount = 50;
        const votes = new Array(38).fill(0);
        
        for (let t = 0; t < treeCount; t++) {
            const prediction = decisionTreePredict(t);
            prediction.forEach(num => {
                votes[num]++;
            });
        }
        
        const result = [];
        for (let i = 1; i <= 37; i++) {
            if (votes[i] > 0) {
                result.push({ num: i, count: votes[i] });
            }
        }
        
        return result
            .sort((a, b) => b.count - a.count)
            .slice(0, 7)
            .map(item => item.num)
            .sort((a, b) => a - b);
    }

    // Ê±∫ÂÆöÊú®‰∫àÊ∏¨
    function decisionTreePredict(seed) {
        const recent = Math.min(100, lotoData.length);
        const freq = new Array(38).fill(0);
        const gaps = new Array(38).fill(0);
        
        // „É©„É≥„ÉÄ„É†„Çµ„É≥„Éó„É™„É≥„Ç∞
        const indices = [];
        for (let i = 0; i < 50; i++) {
            indices.push(Math.floor(Math.random() * recent));
        }
        
        indices.forEach(idx => {
            if (lotoData[idx]) {
                lotoData[idx].numbers.forEach(num => {
                    freq[num]++;
                });
            }
        });
        
        // ÈñìÈöîË®àÁÆó
        for (let num = 1; num <= 37; num++) {
            for (let i = 0; i < recent; i++) {
                if (lotoData[i].numbers.includes(num)) {
                    gaps[num] = i;
                    break;
                }
            }
        }
        
        // „Çπ„Ç≥„Ç¢Ë®àÁÆó
        const scores = [];
        for (let i = 1; i <= 37; i++) {
            const freqScore = freq[i] / 50;
            const gapScore = gaps[i] > 0 ? 1 / (gaps[i] + 1) : 0.5;
            scores.push({
                num: i,
                score: freqScore * 0.6 + gapScore * 0.4 + Math.random() * 0.1
            });
        }
        
        return scores
            .sort((a, b) => b.score - a.score)
            .slice(0, 7)
            .map(item => item.num);
    }

    // „Éë„Çø„Éº„É≥ÂàÜÊûê‰∫àÊ∏¨
    function patternAnalysisPrediction() {
        const candidates = new Set();
        
        // 1. ÈÄ£Á∂öÁï™Âè∑„Éë„Çø„Éº„É≥
        const consecutive = findConsecutivePatterns();
        consecutive.forEach(num => candidates.add(num));
        
        // 2. ÂêàË®àÂÄ§„Éë„Çø„Éº„É≥
        const sumBased = findSumPatterns();
        sumBased.forEach(num => candidates.add(num));
        
        // 3. Â•áÊï∞ÂÅ∂Êï∞„Éê„É©„É≥„Çπ
        const oddEven = findOddEvenBalance();
        oddEven.forEach(num => candidates.add(num));
        
        // 4. ÈñìÈöî„Éë„Çø„Éº„É≥
        const interval = findIntervalPatterns();
        interval.forEach(num => candidates.add(num));
        
        // ÂÄôË£ú„Åå‰∏çË∂≥„ÅÆÂ†¥Âêà„ÅØÈ†ªÂ∫¶ÂàÜÊûê„ÅßË£úÂÆå
        const freq = calculateFrequency(30);
        let i = 0;
        while (candidates.size < 15 && i < freq.length) {
            candidates.add(freq[i].num);
            i++;
        }
        
        // „Çπ„Ç≥„Ç¢„É™„É≥„Ç∞„Åó„Å¶‰∏ä‰Ωç7„Å§ÈÅ∏Êäû
        return Array.from(candidates)
            .slice(0, 7)
            .sort((a, b) => a - b);
    }

    // Áµ±Ë®àÁöÑ‰∫àÊ∏¨Ôºà„Éú„Éº„Éä„ÇπÂØæÂøúÁâàÔºâ
    function statisticalPrediction() {
        const freq = calculateFrequency(100);
        const recentFreq = calculateFrequency(20);
        const gaps = analyzeGaps();
        
        const scores = [];
        for (let num = 1; num <= 37; num++) {
            const overallFreq = freq.find(f => f.num === num);
            const recentItem = recentFreq.find(f => f.num === num);
            
            // Âü∫Êú¨„Çπ„Ç≥„Ç¢Ë®àÁÆó
            const baseFreqScore = (overallFreq?.mainCount || 0) / 100;
            const recentScore = (recentItem?.count || 0) / 20;
            
            // „Éú„Éº„Éä„ÇπËÄÉÊÖÆ„ÅÆ„Çπ„Ç≥„Ç¢
            let bonusScore = 0;
            if (useBonusNumbers) {
                bonusScore = ((overallFreq?.bonusCount || 0) / 100) * 0.3;
            }
            
            // ÈñìÈöî„Çπ„Ç≥„Ç¢
            const mainGaps = gaps[num].main;
            const avgMainGap = mainGaps.length > 0 ? 
                mainGaps.reduce((a, b) => a + b, 0) / mainGaps.length : 20;
            
            let lastGap = 50;
            for (let i = 0; i < lotoData.length; i++) {
                if (lotoData[i].numbers.includes(num)) {
                    lastGap = i;
                    break;
                }
                // „Éú„Éº„Éä„Çπ„Åß„ÅÆÂá∫Áèæ„ÇÇËÄÉÊÖÆ
                if (useBonusNumbers && lotoData[i].bonus && lotoData[i].bonus.includes(num)) {
                    lastGap = Math.min(lastGap, i * 1.5);  // „Éú„Éº„Éä„ÇπÂá∫Áèæ„ÅØ1.5ÂÄç„ÅÆÈáç„Åø
                }
            }
            
            const gapScore = 1 / (lastGap + 1);
            
            // Á∑èÂêà„Çπ„Ç≥„Ç¢
            const totalScore = 
                baseFreqScore * 0.3 +
                recentScore * 0.4 +
                gapScore * 0.3 +
                bonusScore;
            
            scores.push({ num, score: totalScore });
        }
        
        return scores
            .sort((a, b) => b.score - a.score)
            .slice(0, 7)
            .map(item => item.num)
            .sort((a, b) => a - b);
    }

    // „Éû„É´„Ç≥„ÉïÈÄ£Èéñ‰∫àÊ∏¨Ôºà„Éú„Éº„Éä„ÇπÂØæÂøúÁâàÔºâ
    function markovChainPrediction() {
        const transitions = {};
        const bonusTransitions = {};
        
        // ÈÅ∑ÁßªÁ¢∫Áéá„ÇíË®àÁÆó
        for (let i = 1; i < lotoData.length; i++) {
            const current = lotoData[i].numbers;
            const next = lotoData[i - 1].numbers;
            const currentBonus = lotoData[i].bonus || [];
            const nextBonus = lotoData[i - 1].bonus || [];
            
            // Êú¨Êï∞Â≠ó„ÅÆÈÅ∑Áßª
            current.forEach(from => {
                if (!transitions[from]) transitions[from] = {};
                next.forEach(to => {
                    transitions[from][to] = (transitions[from][to] || 0) + 1;
                });
            });
            
            // „Éú„Éº„Éä„Çπ„Åã„Çâ„ÅÆÈÅ∑ÁßªÔºà‰ΩøÁî®„Åô„ÇãÂ†¥ÂêàÔºâ
            if (useBonusNumbers) {
                currentBonus.forEach(from => {
                    if (!bonusTransitions[from]) bonusTransitions[from] = {};
                    next.forEach(to => {
                        bonusTransitions[from][to] = (bonusTransitions[from][to] || 0) + 0.3;
                    });
                });
            }
        }
        
        // ÊúÄÊñ∞„ÅÆÁï™Âè∑„Åã„Çâ‰∫àÊ∏¨
        const lastDraw = lotoData[0].numbers;
        const lastBonus = lotoData[0].bonus || [];
        const predictions = new Array(38).fill(0);
        
        // Êú¨Êï∞Â≠ó„Åã„Çâ„ÅÆ‰∫àÊ∏¨
        lastDraw.forEach(num => {
            if (transitions[num]) {
                Object.entries(transitions[num]).forEach(([to, count]) => {
                    predictions[parseInt(to)] += count;
                });
            }
        });
        
        // „Éú„Éº„Éä„Çπ„Åã„Çâ„ÅÆ‰∫àÊ∏¨
        if (useBonusNumbers) {
            lastBonus.forEach(num => {
                if (bonusTransitions[num]) {
                    Object.entries(bonusTransitions[num]).forEach(([to, count]) => {
                        predictions[parseInt(to)] += count;
                    });
                }
            });
        }
        
        const result = [];
        for (let i = 1; i <= 37; i++) {
            if (predictions[i] > 0) {
                result.push({ num: i, score: predictions[i] });
            }
        }
        
        // „Çπ„Ç≥„Ç¢„Åå0„ÅÆÁï™Âè∑„ÅØÁµ±Ë®àÁöÑ„Å´ËøΩÂä†
        const freq = calculateFrequency(50);
        freq.forEach(f => {
            if (!result.find(r => r.num === f.num)) {
                result.push({ num: f.num, score: f.count * 0.1 });
            }
        });
        
        return result
            .sort((a, b) => b.score - a.score)
            .slice(0, 7)
            .map(item => item.num)
            .sort((a, b) => a - b);
    }

    // ÈÄ£Á∂öÁï™Âè∑„Éë„Çø„Éº„É≥„ÇíÊ§úÂá∫
    function findConsecutivePatterns() {
        const candidates = [];
        const recent = lotoData.slice(0, 10);
        
        recent.forEach(draw => {
            for (let i = 0; i < draw.numbers.length - 1; i++) {
                if (draw.numbers[i + 1] - draw.numbers[i] === 1) {
                    // ÈÄ£Á∂öÁï™Âè∑„ÅÆÂâçÂæå„ÇíÂÄôË£ú„Å´
                    if (draw.numbers[i] > 1) candidates.push(draw.numbers[i] - 1);
                    if (draw.numbers[i + 1] < 37) candidates.push(draw.numbers[i + 1] + 1);
                }
            }
        });
        
        return [...new Set(candidates)];
    }

    // ÂêàË®àÂÄ§„Éë„Çø„Éº„É≥„ÇíÂàÜÊûê
    function findSumPatterns() {
        const sums = lotoData.slice(0, 20).map(draw => 
            draw.numbers.reduce((a, b) => a + b, 0)
        );
        const avgSum = sums.reduce((a, b) => a + b, 0) / sums.length;
        const targetSum = Math.round(avgSum);
        
        // ÁõÆÊ®ôÂêàË®àÂÄ§„Å´Ëøë„Å•„Åë„ÇãÁï™Âè∑„ÇíÈÅ∏Êäû
        const candidates = [];
        for (let num = 1; num <= 37; num++) {
            const contribution = Math.abs(targetSum / 7 - num);
            if (contribution < 10) {
                candidates.push(num);
            }
        }
        
        return candidates;
    }

    // Â•áÊï∞ÂÅ∂Êï∞„Éê„É©„É≥„Çπ„ÇíÂàÜÊûê
    function findOddEvenBalance() {
        const recent = lotoData.slice(0, 10);
        let totalOdd = 0, totalEven = 0;
        
        recent.forEach(draw => {
            draw.numbers.forEach(num => {
                if (num % 2 === 1) totalOdd++;
                else totalEven++;
            });
        });
        
        const avgOdd = totalOdd / recent.length;
        const avgEven = totalEven / recent.length;
        
        // „Éê„É©„É≥„Çπ„ÇíËÄÉÊÖÆ„Åó„ÅüÂÄôË£úÈÅ∏Êäû
        const candidates = [];
        const needMoreOdd = avgOdd < 3.5;
        
        for (let i = 1; i <= 37; i++) {
            if ((i % 2 === 1 && needMoreOdd) || (i % 2 === 0 && !needMoreOdd)) {
                candidates.push(i);
            }
        }
        
        return candidates.slice(0, 10);
    }

    // ÈñìÈöî„Éë„Çø„Éº„É≥„ÇíÂàÜÊûê
    function findIntervalPatterns() {
        const gaps = analyzeGaps();
        const candidates = [];
        
        for (let num = 1; num <= 37; num++) {
            if (gaps[num].length > 2) {
                const avgGap = gaps[num].reduce((a, b) => a + b, 0) / gaps[num].length;
                let lastSeen = -1;
                
                for (let i = 0; i < lotoData.length; i++) {
                    if (lotoData[i].numbers.includes(num)) {
                        lastSeen = i;
                        break;
                    }
                }
                
                if (lastSeen > 0 && Math.abs(lastSeen - avgGap) < 3) {
                    candidates.push(num);
                }
            }
        }
        
        return candidates;
    }

    // „Çπ„Éû„Éº„Éà„Éï„Ç©„Éº„É´„Éê„ÉÉ„ÇØ
    function generateSmartFallback() {
        const freq = calculateFrequency(50);
        const hot = freq.slice(0, 5).map(f => f.num);
        const mid = freq.slice(10, 12).map(f => f.num);
        
        const result = [...hot, ...mid];
        while (result.length < 7) {
            const num = Math.floor(Math.random() * 37) + 1;
            if (!result.includes(num)) {
                result.push(num);
            }
        }
        
        return result.sort((a, b) => a - b);
    }

    // „É°„Ç§„É≥‰∫àÊ∏¨„ÇíË°®Á§∫
    function displayMainPrediction(numbers) {
        const display = document.getElementById('predictionDisplay');
        display.innerHTML = '';
        
        const numbersDiv = document.createElement('div');
        numbersDiv.className = 'prediction-numbers';
        
        numbers.forEach(num => {
            const ball = document.createElement('div');
            ball.className = 'number-ball';
            ball.textContent = num;
            numbersDiv.appendChild(ball);
        });
        
        display.appendChild(numbersDiv);
        
        // ‰ø°È†ºÂ∫¶„ÇíË®àÁÆó„Åó„Å¶Ë°®Á§∫
        const confidence = calculateConfidence();
        displayConfidence(confidence);
    }

    // ÂêÑ„Ç¢„É´„Ç¥„É™„Ç∫„É†„ÅÆÁµêÊûú„ÇíË°®Á§∫
    function displayAlgorithmResults() {
        displayNumberList('ensembleNumbers', predictions.ensemble);
        displayNumberList('neuralNumbers', predictions.neural);
        displayNumberList('forestNumbers', predictions.forest);
        displayNumberList('patternNumbers', predictions.pattern);
    }

    // Áï™Âè∑„É™„Çπ„Éà„ÇíË°®Á§∫
    function displayNumberList(elementId, numbers) {
        const container = document.getElementById(elementId);
        container.innerHTML = '';
        
        numbers.forEach(num => {
            const tag = document.createElement('span');
            tag.className = 'number-tag';
            tag.style.background = '#667eea';
            tag.style.color = 'white';
            tag.textContent = num;
            container.appendChild(tag);
        });
    }

    // ‰ø°È†ºÂ∫¶„ÇíË®àÁÆó
    function calculateConfidence() {
        let confidence = 50; // „Éô„Éº„Çπ‰ø°È†ºÂ∫¶
        
        // „Éá„Éº„ÇøÈáè„Å´„Çà„Çã‰ø°È†ºÂ∫¶Âêë‰∏ä
        if (lotoData.length > 600) confidence += 10;
        else if (lotoData.length > 400) confidence += 7;
        else if (lotoData.length > 200) confidence += 5;
        
        // „É¢„Éá„É´Á≤æÂ∫¶„Å´„Çà„Çã‰ø°È†ºÂ∫¶Âêë‰∏ä
        const accuracy = parseFloat(document.getElementById('modelAccuracy').textContent);
        if (accuracy > 20) confidence += 10;
        else if (accuracy > 15) confidence += 7;
        else if (accuracy > 10) confidence += 5;
        
        // ‰∫àÊ∏¨„ÅÆ‰∏ÄËá¥Â∫¶„Å´„Çà„Çã‰ø°È†ºÂ∫¶Âêë‰∏ä
        const allPredictions = [
            ...predictions.neural,
            ...predictions.forest,
            ...predictions.pattern
        ];
        const consensus = {};
        allPredictions.forEach(num => {
            consensus[num] = (consensus[num] || 0) + 1;
        });
        
        const highConsensus = Object.values(consensus).filter(c => c >= 2).length;
        confidence += highConsensus * 2;
        
        return Math.min(85, confidence); // ÊúÄÂ§ß85%
    }

    // ‰ø°È†ºÂ∫¶„ÇíË°®Á§∫
    function displayConfidence(confidence) {
        const meter = document.getElementById('confidenceMeter');
        const value = document.getElementById('confidenceValue');
        const fill = document.getElementById('confidenceFill');
        
        meter.style.display = 'block';
        value.textContent = confidence;
        
        setTimeout(() => {
            fill.style.width = confidence + '%';
        }, 100);
    }
</script>
```

</body>
</html>